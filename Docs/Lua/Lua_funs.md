# =========================================================//
#                          Lua_funcs
# =========================================================//

# ================================ #
#           _G
# -------------------------------- #
一个全局变量，容纳 全局环境 ／ global environment
lua 自己不使用这些 变量。
改变这些变量 不会影响任何环境 ／ environment
反之亦然

当你不在变量前使用 local 关键字的时候，
这个变量会被放在 _G 这个全局表中。

# ================================ #
#           _VERSION
# -------------------------------- #
一个全局变量, 存储一个字符串，表示lua版本
通常为 "Lua 5.3"

# ================================ #
#      assert (v [, message])
# -------------------------------- #
当 参数v 为 false／nil，调用 error函数
否则，returns all its arguments

参数 message 为出错信息 ／ error object
如果不设置，将使用默认值 “assertion failed!”


# ================================ #
#     error (message [, level])
# -------------------------------- #
终止 最后一个 受保护的函数调用／the last protected function called (?)
参数 message 为出错信息 ／ error object
本函数永远不 返回 ／ return

参数 level 指定了如何获得 error postion
level 默认为 1. 此时，error position 指向 error函数被调用的位置。
level = 2，则，error position 指向 “调用error的函数” 被调用的位置。
以此类推

level = 0。则阻止将 error position 添加到 error msg 中（不显示）


# ================================ #
#   load (chunk [, chunkname [, mode [, env]]])
# -------------------------------- #
Loads a chunk.

如果 参数chunk 是字符串，那么 最终chunk 就是这组字符串
如果 参数chunk 是个 function 类型数据，
    本函数将 不停地调用这个函数，来获得所有 chunk pieces
    每次调用 函数chunk，都必须返回一个 字符串，
    且这个 返回字符串，需要与 之前返回的字符串 相关联
    如果某次返回值是 空字符串，nil，或无返回值，
    标志着 函数chunk 调用的终止。

如果整个过程没有 句法error。 将编译好的 chunk，以 function的格式 返回。
否则，返回 nil，外加 error msg

如果最终获得的 function 拥有 upvalues.
第一个 upvalues 被设置为 参数env 的值。
如果 参数env 未设置，则将 第一个 upvalues 设置为 global environment。
剩余的 upvalues 被以 nil 初始化。

如果 load 的是 main chunk，返回的 function 总是拥有一个 upvalues：_ENV
然而，如果 load 的 二进制chunk 是由一个 function生成的， 那么 返回的function
可以拥有 任意数量的 upvalues。
所有的 upvalues 都是新鲜的，它们不与 其他任何 function 分享。

参数chunkname 被用于 error msg 和 debug info
如果此参数未设置，
    -- 如果参数chunk 为字符串，参数chunkname 被默认设置等于它
    -- 否则，参数chunkname 被默认设置为  "=(load)"

参数mode 是个字符串，
    -- "b"  -- only binary chunks
    -- "t"  -- only text chunks
    -- "bt" -- both binary and text (默认值)

lua 并不检测 二进制chunk 的连贯性(?)
怀有恶意的 二进制chunk，可以使 解释器崩溃。


# ================================ #
#    loadfile ([filename [, mode [, env]]])
# -------------------------------- #
与函数 load 相似。
不同在于，要么从 参数filename 处获得 chunk 来源
要么从 stdin 获得，



# ================================ #
#       dofile ([filename])
# -------------------------------- #
打开 目标文件，并将它的内容当作一个 lua chunk 来运行 
当没有参数时，本函数 执行 stdin 输入得 数据

返回值就是 目标chunk返回的 一切数据

本函数并不运行在 protected mode，
而是将自己运行期间的 error，统统返回给 dofile函数的 调用者


# ================================ #
#   setmetatable (table, metatable)
# -------------------------------- #
为 参数table 设置一个 元表，也就是 参数metatable 

如果 参数metatable 为 nil，则将移除 参数table 的元表
此时，如果 原来的 元表 拥有一个 __metatable 字段
将引发一个 error


# ================================ #
#    getmetatable (object)
# -------------------------------- #
获得 参数object 的元表
如果参数没有 元表，返回 nil。
否则，如果 参数obj 拥有一个 __metatable 字段，返回 相关联的变量
否则，返回 参数obj 的元表


# ================================ #
#      tostring (v)
# -------------------------------- #
参数v 可以为任何类型。并将它转换为 人类可读的形式。

如果 参数v 的元表 拥有 __tostring 字段（一个方法／函数），
本函数 将调用这个函数 来完成工作，将 参数v 作为参数传入 __tostring
然后把 __tostring 函数的返回值 当作 本函数自己的返回值 返回出来

本函数 常用于 print 函数的实现。

# ================================ #
#       print (···)
# -------------------------------- #
接受任何类型的参数，并将它们输出到 stdout。
通过 tostring函数，将每个参数 转换为 字符串
本函数不是用来做 格式化打印的（比如 c 中的 printf）
仅仅用于 快速显示 某些变量。比如用于 debug

正式的输出，可以使用 string.format ／ io.write


# ================================ #
#     
# -------------------------------- #


# ================================ #
#     
# -------------------------------- #


# ================================ #
#     
# -------------------------------- #

# ================================ #
#     
# -------------------------------- #


# ================================ #
#     
# -------------------------------- #


# ================================ #
#     
# -------------------------------- #

# ================================ #
#     
# -------------------------------- #


# ================================ #
#     
# -------------------------------- #


# ================================ #
#     
# -------------------------------- #




