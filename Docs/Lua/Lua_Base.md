# ========================================================= #
#                          Lua Base
# ========================================================= #


# 参考手册
https://www.runoob.com/manual/lua53doc/

http://www.lua.org/manual/5.3/


# ==================================================== #
#          在线写代码
# ---------------------------------------------------- #
https://wiki.luatos.com/_static/luatos-emulator/lua.html



# ==================================================== #
#                      安装   [ mac ]
# ---------------------------------------------------- #

# ======== 方法一，homebrew ======
    brew install lua

# ======== 方法二，本地编译 [- 推荐 -] ======

# ==1== 下载 ==

    下载 Lua 5.3 安装包 from：
    https://www.lua.org/

# ==2==  编译 ==

    在 安装包更目录，执行： make
    -- 此时会跳出 一组平台名 列表。
    -- 比如在 mac 上，执行： make macosx

=   编译完成后，会在 /src/目录下，创建三个 新文件：
    -- lua  :  解释器
    -- luac :  编译器
    -- liblua.a : 库文件

=   为了检测 lua 是否 build 正确，执行： make test
    这将运行 解释器，并打印版本号


# ==3== 安装 ==

=   如果想要 安装到 操作系统默认路径
    执行 make install 
    -- 默认安装路径 定义在 makefile 文件中


=   如果想要安装到 当前目录（lua源代码root目录，.../lua-5.3.5/ ）
    [推荐]
    执行：make local
    会在 .../lua-5.3.5/ 目录下 新建一个目录 install/
    然后将 lua 安装进这个 install/ 目录中，结构如下：
=    bin:
        lua luac
=    include: （ include 下的一个 子目录 include ）
        lua.h luaconf.h lualib.h lauxlib.h lua.hpp
=    lib:
        liblua.a
=    man/man1:
        lua.1 luac.1

=  bin/, man/ 目录下的文件用于 运行 lua程序
=  include/, lib/ 目录下的文件用于 将 lua 嵌入到 C/C++ 程序中



# ==================================================== #
#                 运行 lua 小程序 
# ---------------------------------------------------- #

#--  制作一个 名为 xxx.lua 的文件。
#--  在头部写入：
    #!/usr/local/bin/lua
     从而设置 此脚本的 执行程序
     （就像 shell 一样）
    
#--  在文件所在目录中执行：
    chmod  u+x  xxx.lua
     
#--  执行：
    ./xxx.lua


# ==================================================== #
#                    语法
# ---------------------------------------------------- #

# ======  注释  ======
#     -- xxxx
      单行注释

#     --[[  xxxx
#           xxxx
#     --]]  
      多行注释


# ======  标示符／变量名  ======
  不要使用 下划线+大字母 的名字,比如:
    _VERSION 
  这是 lua 保留字 的用法。

# ======  关键词  ======
    and
    break
    do
    else
    elseif
    end
    for
    function -- 由 C／Lua 编写的函数 
    if
    in
    local
    nil  -- 表示一个 空变量／无效值
    not
    or
    repeat
    return
    then
    true   -- type: boolean 0 也表示 true
    false  -- type: boolean
    until
    while

# ======  全局变量  ======

#--    新建的变量，默认为 全局变量
#--    一个 未初始化的 全局变量，值为 nil
#--    若想删除一个 全局变量，只需将其赋值为 nil
        这个变量 就好像从没被使用过一样
        当且仅当一个变量不等于 nil 时，这个变量 即被看做存在


# ======  数据类型  ======
#    一共 8 种：

    nil      -- 只有值 nil 属于该类
                表示一个无效值（在条件表达式中相当于false）

    boolean  -- 包含两个值：false 和 true
                只有 false 和 nil 代表 假, 剩余一切值都为 真

    number   -- integer -- int64
                float   -- 双精度浮点数 (类比 double )

    string   -- 字符串由一对双引号或单引号来表示

    function -- 由 C 或 Lua 编写的函数

    userdata -- 表示任意存储在变量中的C数据结构

    thread   -- 表示执行的独立线路，用于执行协同程序

    table    -- "关联数组"/associative arrays
                数组的索引可以是 数字 或者是 字符串
                table 的创建是通过 "构造表达式" 来完成，
                最简单构造表达式是 {}，用来创建一个空表

#    print( type( "koko" ) )
#    --> string
    通过 type() 函数 来测试 值的类型


# ----------------------------------------------#
#         type: userdata 
# ----------------------------------------------#
The type userdata is provided to allow arbitrary C data to be stored in Lua variables. This type corresponds to a block of raw memory and has no pre-defined operations in Lua, except assignment and identity test. However, by using metatables, the programmer can define operations for userdata values (see §2.8). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program.
-------

这个类型是为了让 任意的 c数据 存储在一个 lua 变量中;
这个类型代表一个 生二进制 数据块, lua 不存在对它的 预定义操作; (但是 lua 可以为它 分配内存, 以及 身份验证)
但是, 通过使用 metatable, 程序员可定义对 userdata 类型变量的 操作;
不能在 lua 中创建 和 修改 userdata 变量, 只能通过 c api 来生成和改写;
这保证了 宿主程序对 这些数据的 完整拥有权;







# ----------------------------------------------#
#           真 假
# ----------------------------------------------#
# 只有 false 和 nil 代表 假, 剩余一切值都为 真 !!!

比如, 0 就代表 真

# ----------------------------------------------#
#            and / or / not
# ----------------------------------------------#

# 原则上, and, or, not 其实符合常规语言中的 &&, ||, ! 操作;
# 但是, 这三个运算符返回的不是 bool 类型元素, 而是它的操作数:

#  and: 
    若第一操作数 是 false/nil, 返回第一操作数 (即 false/nil )。否则反而第二个

nil   and 13 --> nil
false and 13 --> false
7     and 13 --> 13

#  or:
    若第一操作数 不是 false/nil, 返回第一操作数。否则反而第二个

nil   or 13 --> 13
false or 13 --> 13
7     or 13 --> 7
0     or 13 --> 0


# 用法: (有点类似 三元运算符)
    a = 0
    print( a>1 and "yes" or "no" )

将返回 "no", 
如何分析:
首先运行 and 这一对, 因为 a>1 为假, 所以 and 这对返回 nil,
表达式变成了:
    nil or "no"
此处, "no" 为真, 所以最终返回 "no"






# ----------------------------------------------#
#     不等于: ~= 
# ----------------------------------------------#
注意, 不是用 != 来表达;

# ----------------------------------------------#
#     两个字符串的连接 ..
# ----------------------------------------------#
a = "ko"
b = "12"
c = a..b

用 ".." 来连接两个字符串; 注意, 也可写成 "a .. b" (允许存在空格)


# ----------------------------------------------#
#     分支判断 if:
# ----------------------------------------------#

    if a>1 then
        -- do a
    elseif a>0 then
        -- do b
    else
        -- do c
    end


# ----------------------------------------------#
#     for 循环
# ----------------------------------------------#

# -1- 常规理解的循环, 每回合 i 加 1:
    for i=1,10 do
        -- something
    end

# -2- 指定步长版, 每回合 i 加 2:
    for i=1,10,2 do
        -- something
    end


# 不允许在 for 循环内对 i 这个值进行修改 !!!!!
    如果你修改了 i, 那句话会被 lua 强制改为: local i = "..."
    等于给你新建了一个本地变量 i, 还是无法影响循环使用的那个 i;

# 可以使用 break;



# ----------------------------------------------#
#     while 循环
# ----------------------------------------------#
    local n = 10
    while n>0 do
        n = n -1      -- lua 中没有 "n--" 这种自减操作符
    end




# ----------------------------------------------#
#  字符串 数值 转换
#     tostring
#     tonumber
# ----------------------------------------------#
a = tostring(10)   -- 得到字符串 "10"

b = tonumber("10")  -- 得到数值: 10

# 如果 转换失败, 则返回 nil;


# ----------------------------------------------#
#  获得字符串长度: #
# ----------------------------------------------#
a = "123"
b = #a      -- 得到数值: 3

# -- "#" 也可用来获取一个 table 的元素个数
    t = {1,2,3}
    print( #t )


# ----------------------------------------------#
#     # 和 string.len(s) 的区别
# ----------------------------------------------#
当用于 string 时, 两个操作时等价的, 都能得到 string 的字节数;

但是 # 可获得任意 table 的连续元素个数; (若中间有空洞, 则在第一个空洞位置被中断, 只得到前面部分的元素个数)

# 若使用 string.len 去访问一个 普通 table 的元素个数, 将报错;




# ----------------------------------------------#
#         长字符串 [[ koko ]]
# ----------------------------------------------#

longstr = [[
a
bb
"koko"
ccc
]]

print(longstr)

#   通过 [[ ... ]] 来实现一个跨越多行的 长字符串
#   优点：
#   -1- 内部的所有符号可以原样打印，比如 " 这种，不会自动转意
#   [[后面如果紧跟着一个 '\n' 符，这个 换行符将被忽略。

#   是记载字符串的 理想方式。

# ------
#   如果在这个字符串内部也有 [ ] 怎么办？

longstr = [===[
a
b
[c]
d
e
]===]

#   首位界符中的等号数量一定要相符。
#   并且避免在 字符串中 再出现 相同的 符号



# ----------------------------------------------#
#     func{table_a} = func( {table_a} )
#     func{a,b,c} = func( {a,b,c} )
# ----------------------------------------------#
   当参数为一个 表，表构造器时，可以省略 函数调用的 小括号




# ----------------------------------------------#
#   函数的声明 function
# ----------------------------------------------#

# -1- 函数名放后面
    function Foo(...)
        -- func body
    end

# -2- 函数名放前面
    Foo = function(...)
        -- func body
    end

# 返回值
-1-
    若函数没写 return 语句, 则默认返回 nil
-2-
    return ...
    可以一次返回多个值, 比如: return a,b,c
    多个返回值, 可以配合 多重赋值语句



# ----------------------------------------------#
#   函数的 可选参数
# ----------------------------------------------#

    Boo( a,[, b, [, c]] )

此处的 b, c 就是可选参数;




# ----------------------------------------------#
#   table   (数组风格的)
# ----------------------------------------------#

# -1-:
    a = { 1, "koko", {}, function() end }

上面这个 table 里可以存任何类型的数据, 甚至一个函数

# 访问的时候, 下标从 1 开始数;
    a[1]

# 如果下标越界,比如 a[99], 则返回 nil

# ------
# 单独对 table 一个元素进行赋值:
    a = {1,2}
    a[99] = "koko"
    print(a[98])   -- 得到: nil
    print(a[99])   -- 得到: "koko"


# ----------------------------------------------#
#  table 元素 value 为 nil
# ----------------------------------------------#

    t = {
        a = 1,
        b = nil,
        c = 3,
    }

    for k,_ in pairs(t) do 
        print( k,_ )
    end
    -----

注意观察, 元素 b 的值为 nil, 此时用 for去遍历 t, 将直接跳过 b 这个元素;

# 利用这个特征, 可以让很多代码 被简化;





# ----------------------------------------------#
#  获得 table 长度: #
# ----------------------------------------------#
    a = {1,2}
    a[99] = "koko"
    print( #a )    -- 最终得到: 2, 因为虽然存在 [99] 元素, 但从第3个元素开始断了, 程序不再往下查找;


# ----------------------------------------------#
#   table.insert( tableA, element)
# ----------------------------------------------#

# -- table.insert( tableA, element)
    在尾后 插入一个元素

# -- table.insert( tableA, 2, element)
    在 第二个元素位置插入, 原来的 2号元素后移


#  table.remove( tableA, 2 )
    移除 table 中的 2 号元素;
    并将移除的这个元素 返回出去



# ----------------------------------------------#
#   table   ( key-value 风格的 )
# ----------------------------------------------#
    tb = {
        a = 1
        b = "ko"
        c = {}
    }

    print( tb["a"] )  -- 可以发现是用 key 去搜索值的;
    print( tb.a )     -- 另一种访问方式, 

# 还可以再添加元素:

    tb[",,."] = 12      -- 添加了一个元素
    print( tb[",,."] )  -- 得到: 12


# ----------------------------------------------#
#      require
# ----------------------------------------------#

首先创建一个 lua 文件: a/b/ko.lua

然后在另一个文件里运行这个文件, 可以写: 
    require("a.b.ko")

# -- 注意, 不需要写后缀名 .lua

# -- 目录层次用 . 区分

# -- 调用 require 只会运行一次目标文件;
不管你在一个文件里重复调用多少次 require("ko"),  最终只会运行一次;

想要多次调用, 改用 dofile, load stream 等函数才行 (拼写可能有问题)

# -- require 会从 package.path 路径内查找 目标文件;


require 实际上是调一个个的 loader 去加载，有一个成功就不再往下尝试，全失败则报文件找不到。 
目前 xLua 除了原生的 loader 外，还添加了从  Resource 加载的 loader，需要注意的是因为 Resource 只支持有限的后缀，
放 Resources 下的 lua 文件得加上 txt 后缀（见附带的例子）。

建议的加载 Lua 脚本方式是：整个程序就一个 DoString("require 'main'")，然后在 main.lua 加载其它脚本（类似 lua 脚本的命令行执行：lua main.lua）。

有童鞋会问：要是我的Lua文件是下载回来的，或者某个自定义的文件格式里头解压出来，或者需要解密等等，怎么办？问得好，xLua的自定义Loader可以满足这些需求。



# ----------------------------------------------#
#    迭代器-1-: ipairs   (适合迭代 数字下标的 table)
# ----------------------------------------------#

# 手动编写迭代:
    t = {"a","b","c"}

    for i=1, #t do
        print( i, t[i] )
    end

# ipairs:

    for i,j in ipairs(t) do
        print( i, j )
    end
    ---
    把 下标 i 给 i, 把 t[i] 给 j;

# 缺点, 如果这个 table 下标不连续, 比如
t = {1,2}
t[9] = 9;

此时使用 ipairs 只能遍历前面 2 个元素, 到第三个就终止了, [9] 元素会被丢失;

# 此时可改用 pairs 迭代器:


# ----------------------------------------------#
#    迭代器-2-: pairs   (同事适合 数字下标的 table, 和 key-value 格式的 table)
# ----------------------------------------------#
    t = {
        a = "1"
        b = "2"
        c = "3"
    }
    for i,j in pairs(t) do
        print( i, j )
    end

# 不管 table 内放了什么元素, 都能完整迭代完

# pairs 内部依赖一个 next() 函数



# ----------------------------------------------#
#     元表 metatable
# ----------------------------------------------#
metatable 自己也是一个普通的 table, 但是它可以存放一些类似 运算符重载函数
之类的 元函数; 然后这些 重载函数并不是服务于 metatable 自己的, 而是服务于另一个 普通 table:

    t = {a=15}
    mt = {
        __add = function(a,b)
            return a.a+b
        end
    }
    setmetatable(t,mt)   -- 为一个普通table: t 设置它的元表: mt

上例可看出, 元表 mt 定义了一个 加法重载, 然后绑定之后, t 的 加法运算就被更改了;



# ----------------------------------------------#
#      面向对象
# ----------------------------------------------#

# 一个语法糖: " 冒号 : "
    t = {
        a = 0,
        add = function(tab, sum)
            tab.a = tab.a + sum
        end
    }

    t.add(t,10)   -- 常规写法
    t:add(10)     -- 面向对象写法


# 用上述语法糖, 实现 lua 的 面向对象:
https://www.bilibili.com/video/BV1WR4y1E7ud?p=7 第7课

bag = {}
bagmt = {
    put = function(t,item)   -- 放入一个元素
        table.insert( t.items, item )
    end,
    take = function(t)       -- 取出一个元素
        return table.remove( t.items, item )
    end,
    list = function(t)       -- 将所有元素练成一个 string, 中间用 ',' 分隔;
        return table.concat( t.items, "," )
    end,
    clear = function(t,item)   -- 清空表
        t.items = {}
    end,

}
bagmt["__index"] = bagmt   -- 这样一来,当 bag 中找不到目标元素时, 就会到 bagmt 中去找

function bag.new()
    -- 为每个新实例准备一个专属于它的 table: t 
    local t = {
        items = {}
    }
    setmetatable(t,bagmt)
    return t
end
-------

local b = bag.new()  -- 现在可用 new() 新建很多个实例了
b:put("apple1")
b:put("apple2")
print( b:list() )



# ----------------------------------------------#
#      协程
# ----------------------------------------------#








