

# ================================================================ #
#                           signal
# ================================================================ #
信号， APUE 第 10 章

信号是 异步事件的经典实例，产生信号的事件 对于进程而言是随机出现的。
进程不能简单地测试一个变量（如errno）来判断是否发生了一个信号，
而是必须告诉内核，“当某信号发生时，请执行下列操作”。

# ---------------------- #
#       信号的处理
# ---------------------- #
在某信号出现时，可告诉内核下列 3 种方式之一来处理：

#-1- 忽略此信号。
    大部分信号可用此方式处理，有两种信号例外：
    -- SIGKILL
    -- SIGSTOP
        此 2 信号 向内核和 root 提供了使进程终止或停止的可靠方法。

    此外，如果忽略某些硬件异常信号（如非法内存引用 或 除0），
    则进程的运行行为是 未定义的。

#-2- 捕捉信号。
    需要通知内核 在某信号发生时，调用一个用户函数。

    不能捕捉的信号：
    -- SIGKILL
    -- SIGSTOP

#-3- 执行系统默认动作。
    对于大多数信号，系统默认动作是 终止此进程






# ======================= #
#       signal 常量
# ======================= #
linux 支持 31 种信号。也支持另外的应用程序定义的信号


放置 信号常量 的头文件。
信号常量都是 正整数。没有编号0 的信号。
#include <signal.h>
    //-- 包含了 <bits/signum.h>，常规代码 调用 <signal.h> 即可
#include <bits/signum.h> 
    //-- linux 中，信号常量的实际存放地

# --------------------------

#  0
    空信号
    没有编号0 的信号。
    kill 函数 对 编号 0 有特殊应用， 10.9

#  SIGABRT
    夭折信号 ／ 异常终止 ／ abort
    当进程调用 abort 函数时，产生这种信号
    （ 终止 + core ）

#  SIGALRM
    闹钟信号 ／ 定时器超时信号 ／ alarm
    由 alarm 函数设置的 定时器 超时后 将产生的信号。 10.10
    若由 setitimer(2) 函数设置的 间隔时间已超时，也产生此信号
    （ 终止 ）

#  SIGBUS
    硬件故障
    当出现某些类型的 内存故障时，常产生此信号 14.8
    （ 终止 + core ）

#  SIGCANCEL  ---- [ Linux 无 ] ----
    线程库内部使用 
    - Solaris -
    （ 忽略 ）

#  SIGCHLD
    子进程状态改变
        当一个进程终止或停止时，此信号被送给 其父进程。
        系统默认忽略此信号。
        如果 父进程 希望被告知 其子进程的 这种状态改变，则应捕捉此信号。
        - 有写古老软件 还使用信号 SIGCLD -
         SIGCLD 和 SIGCHLD 存在一点区别， 10.7
    （ 忽略 ）

#  SIGCONT
    使暂停进程继续
    当一个进程接收到此信号，如果该进程处于 停止状态，则系统默认动作是 使其继续运行
    如果该进程 不处于 停止状态，则 系统默认动作是 忽略此信号
    （ 继续／忽略 ）

#  SIGEMT
    硬件故障
    指示 一个实现定义的 硬件故障
    EMT -- emulator trap / 仿真器陷阱
    - Linux 只对 SPARC, MIPS, PA_RISC 等系统结构 支持 此信号 -
    （ 终止 + core ）

#  SIGFPE
    算术异常
    如 除0， 浮点溢出
    （ 终止 + core ）

#  SIGFREEZE  ---- [ Linux 无 ] ----
    检查点冻结
    通知进程在 冻结系统状态之前 需要采取特定动作。
    例如当 系统进出 休眠 或 挂起状态 可能需要做这种处理
    - Solaris -
    （ 忽略 ）

#  SIGHUP
    连接断开
    如果 终端接口，检测到一个 连接断开，则将此信号 送给 与该终端相关的 控制进程（会话首进程）。 图 9-13
    ...
    如果会话首进程终止，也产生此信号，此时，此信号送给 前台进程组中的 每个进程。

    通常 此信号 通知 守护进程 再次读取它们的 配置文件，
    选用 SIGHUP 的理由是：守护进程不会有控制终端，通常不会接收到这种信号。
    （ 终止 ）

#  SIGILL
    非法硬件指令
    表示 进程 已执行一条 非法硬件指令。
    （ 终止 + core ）

#  SIGINFO  ---- [ Linux 无 ] ----
    键盘状态请求
    BSD信号，当用户按下状态键（ctl+T），终端驱动程序产生 此信号 并发送至前台进程组中的 每一个进程。
    此信号通常造成在 终端上显示前台进程组中各进程的状态信息。
    （ 忽略 ）

#  SIGINT
    中断信号 ／ 终端中断符
    在 终端上 按 Delete 健，或 ctl+C，产生此信号，并发送至前台进程组中的每个进程。
    用这个方法来 停止一个 失去控制的程序，
    18 章 介绍，此信号可被映射为 终端上的 任一字符
    （ 终止 ）

#  SIGIO
    异步IO
    14.5.2
    - linux中，SIGIO, SIGPOLL 具有相同值，默认行为是（ 终止 ） -
    （ 终止／忽略 ）

#  SIGIOT
    硬件故障
    IOT -- input/output TRAP 指令 ( PDP-11 )
    - linux 中，SIGIOT, SIGABRT 具有相同值 -
    （ 终止 + core ）

#  SIGJVM1  ---- [ Linux 无 ] ----
#  SIGJVM2  ---- [ Linux 无 ] ----
    java虚拟机内部使用
    - Solaris -
    （ 忽略 ）


#  SIGKILL
    终止
    不能被 捕捉，也不能被 忽略。
    像 root 提供一种 可以杀死任何进程的 可靠方法。
    （ 终止 ）

#  SIGLOST  ---- [ Linux 无 ] ----
    资源丢失
    （ 终止 ）

#  SIGLWP  ---- [ Linux 无 ] ----
    线程库内部使用
    （ 终止／忽略 ）

#  SIGPIPE
    在管道的读进程终止后，一个进程写此管道 15.2
    当类型为 SOCK_STREAM 的套接字 已不再连接时，进程 对该套接字 执行 写，也会产生此信号。 16章
    （ 终止 ）

#  SIGPOLL
    可轮询事件 ／ poll
    - 准弃用 -
    当在一个 可轮询设备上 发生一个 特定事件时，产生此信号。 14.4.2
    - linux中，SIGIO, SIGPOLL 具有相同值，默认行为是（ 终止 ） -
    （ 终止 ）

#  SIGPROF
    梗概时间超时 ／ setitimer
    - 准弃用 -
    当 setitimer(2) 函数设置的 梗概统计间隔定时器 ／ profiling interval timer
    已经超时时 产生此信号
    （ 终止 ）

#  SIGPWR
    电源失效 ／ 重启
    主要用于 具备 不间断电源／UPS 的系统。如果电源失效，则 UPS 起作用，而且通常软件会接到通知。
    此时 系统依靠蓄电池工作，当蓄电池也不能支持工作时，则软件通常会再次接到通知，此时系统必须使各部分
    停止运行，此时应 发送 SIGPWR 信号。
    在大多数系统中，接到蓄电池电压过低信息的 进程将信号 SIGPWR 发送给 init进程，
    然后由 init 处理停机操作。
    - Linux 默认动作是 终止相关进程 -
    （ 终止／忽略 ）

#  SIGQUIT
    终端退出符
    在终端上按 退出健 ctl+\ 时，中断驱动程序 产生此信号，并发送给前台进程组所有进程 图9-9
    此信号 不仅 终止前台进程组（如 SIGINT 一样），同时产生一个 core 文件。
    （ 终止 + core ）

#  SIGSEGV
    无效内存引用
    硬件异常信号 之一
    由硬件检测到，并通知内核，然后内核 为对应进程 产生适当信号。
    当某进程 试图 执行一个无效内存引用。产生此信号
    或者 访问一个 未经初始化的 指针。
    SEGV -- segmentation violation / 段违例
    （ 终止 + core ）

#  SIGSTKFLT
    协处理器 栈故障
    仅由 linux 定义。出现在 linux 早期版本，企图用于 数学协处理器的 栈故障
    该信号 并非由 内核产生，但仍保留以向后兼容。
    （ 终止 ）

#  SIGSTOP
    停止一个进程
    作业控制信号，类似 SIGTSTP / 交互停止信号
    不能被 捕捉 或 忽略。
    （ 停止进程 ）

#  SIGSYS
    无效系统调用
    （ 终止 + core ）

#  SIGTERM
    终止
    由 kill(1)命令 发送的 系统默认终止信号，
    该信号由 应用程序捕获，使用该信号 让程序 有计划在 退出之前做好 清理工作，
    比 SIGKILL 好一些（ SIGKILL 不能被捕捉或忽略，是强行终止进程 ）
    （ 终止 ）

#  SIGTHAW  ---- [ Linux 无 ] ----
    检查点解冻
    - Solaris -
    在被挂起的 系统恢复时，该信号用于通知相关进程，这些进程需要采取特定的动作
    （ 忽略 ）

#  SIGTHR  ---- [ Linux 无 ] ----
    线程库内部使用
    - FreeBSD -
    （ 忽略 ）

#  SIGTRAP
    硬件故障
    TRAP -- TRAP 指令（ PDP-11 ）
    当执行断点指令时，实现常用此信号 将 控制转移至 调试程序。
    （ 终止 + core ）

#  SIGTSTP
    终端停止符 ／ 交互停止信号
    在终端 按下 挂起健：ctl+Z, 终端驱动程序 产生此信号。
    该信号 发送至 前台进程组中的 所有进程. 图 9-9
    （ 停止进程 ）

#  SIGTTIN
    后台 读 控制 tty
    当一个 后台进程组 试图读其控制终端时，终端驱动程序 产生此信号 9.8
    在下列例外情况下 不 产生此信号：
    -- 读进程 忽略或阻塞 此信号
    -- 读进程 所属的 进程组是 孤儿进程组。此时 读操作返回出错，errno设置为 EIO
    （ 停止进程 ）

#  SIGTTOU
    后台 写 控制 tty
    当一个 后台进程组 试图写其控制终端时，终端驱动程序 产生此信号 9.8
    与 SIGTTIN 不同，一个进程 可以选择 允许后台进程写控制终端。 18章 
    如果 不允许 后台进程写，则与 SIGTTIN 相似：两种情况下 不产生此信号：
    -- 写进程 忽略或阻塞 此信号
    -- 写进程 所属进程组 是 孤儿进程组，此时不产生此信号，写操作返回出错，errno 设置为 EIO

    无论 是否允许后台进程写，一些除写以外的 下列终端操作 也能参数 SIGTTOU 信号：
    如 tcsetattr, tcsendbreak, tcdrain, tcflush, tcflow,tcsetpgrp  18章
    （ 停止进程 ）

#  SIGURG
    紧急情况 （套接字）
    在网络连接上传来 带外数据时
    （ 忽略 ）

#  SIGUSR1
#  SIGUSR2
    用户定义信号，可用于 应用程序。
    （ 终止 ）

#  SIGVTALRM
    虚拟时间闹钟 setitimer
    当一个 由 setitimer(2) 函数 设置的虚拟间隔时间 已经超时时，产生此信号。
    （ 终止 ）

#  SIGWAITING  ---- [ Linux 无 ] ----
    线程库内部使用
    - Solaris -
    （ 忽略 ）

#  SIGWINCH
    终端窗口大小改变
    进程可以用 ioctl函数（18.12）得到或设置窗口大小。
    当进程使用 ioctl 更改窗户大小后，内核将 SIGWINCH 信号 发送至前台进程组。
    （ 忽略 ）

#  SIGXCPU
    超过 cpu 限制 setrlimit  7.11
    （ 终止 或 终止+core ）

#  SIGXFSZ
    超过文件长度限制 setrlimit  7.11
    （ 终止 或 终止+core ）

#  SIGXRES  ---- [ Linux 无 ] ----
    超过资源控制
    - Solaris -
   （ 忽略 ）












