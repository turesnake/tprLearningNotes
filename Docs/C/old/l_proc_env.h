//
//========================= l_proc_env.h ==========================
//                         -- NET --
//                                        创建 -- 2018.06.14
//                                        修改 -- 2018.06.14
//----------------------------------------------------------
//   专门存放 进程环境 模块 的 函数。 
//    APUE 第 7 章
//
//---------------------------------

#ifndef _NET_PROC_ENV_H_
#define _NET_PROC_ENV_H_

//---------------------------------
//-- 终止一个进程
#include  <stdlib.h> //-- ISO C 标准 中的设定

void exit( int status );
    //-- 首先 调用 各个 终止处理程序，
    //-- 执行 一个 stdio库的 清理关闭操作，对所有打开流调用 fclose 函数。
    //-- 使得 输出缓冲中的 所有数据 都被冲洗 到 磁盘文件内。
    //-- 然后返回内核

void _Exit( int status );
    //--  立即进入内核

#include  <unistd.h>//-- POSIX.1  标准 中的设定

void _exit( int status );
    //--  立即进入内核


//---------------------------------
//-- 登记 终止处理程序 / exit handler
#include  <stdlib.h> 

int atexit( void (*func)(void) );
        //-- ISO C 规定中，一个进程 可登记 32个函数，它们由 exit自动调用。
        //-- 这些函数是 终止处理程序 / exit handler。
        //-- atexit 函数 用来 登记 它们。

        //-- 参数 func 是一个 函数指针／地址，此函数 无参数 也 无返回值。

        //-- exit调用 这些函数时的顺序 和 它们登记的次序 相反。
        //-- 允许 同一函数 登记多次

        //-- return:
        //-- 成功，返回 0。
        //-- 出错，返回 非0.

//---------------------------------
//-- 存储空间分配
//-- 以下三种 分配函数 常通过 sbrk系统调用 来实现自己。
//-- 这些函数 实际分配的 空间 会比 要求的 更大一些。额外的空间用来记录管理信息：
//-- 比如 分配块的长度，指向 下一个分配块的指针等。
#include  <stdlib.h> 

void* malloc( size_t size );
        //-- 分配 制定字节数的 存储区， 此存储区中的 值不确定（未初始化）
        //--

void* calloc( size_t nobj, size_t size );
        //-- 为 nobj 个 对象（每个大小为 size），分配存储空间，且将空间全部初始化为 0.
        //--

void* realloc( void* ptr, size_t newsize );
        //-- 增加／减少 一个旧存储区 的大小。
        //-- 当增加长度时.如果该存储区后方有足够内存空间可供扩充，则直接扩充。
        //-- 若没有足够空间，则需要将 旧存储区中的 数据 移到另一个足够大的 区域中
        //-- 以便在 尾端 提供增加的 存储区，同时，新增加的那段存储区没有给初始化。
        //-- 此时，旧的 存储区会被释放掉。
        //-- 由于 这一过程可能 改变存储区的位置，所以不应使任何指针 指向 这类存储区。

        //-- param:
        //-- ptr     -- 指向 旧存储区。
        //              若 ptr == NULL，此时的 realloc 与 malloc 功能相同
        //-- newsize -- 新的存储区的 完整长度，不是新区和旧区 的差值。

        //-- 三个函数的 return:
        //-- 成功，返回 非空指针
        //-- 出错，返回 NULL

//---------------------------------
//-- 环境变量值。
//-- 环境字符串： name=value 
#include  <stdlib.h> 

//-- 每个程序 都接收一张 环境表。是一个 字符指针数组。
//-- 每个指针，指向一个以null结束的 字符串。
//-- 全局变量 environ ，则指向 当前进程所绑定的  环境表。
//-- 尽量使用 getenv, 而不要直接访问 environ. 
extern char** environ; 

char* getenv( const char* name );
        //-- 根据参数 name，获得 环境变量中，对应的 value 的指针。
        //-- 

        //-- return:
        //-- 若找到，返回 指向与 name 关联的 value 的指针
        //-- 若未找到， 返回 NULL。

int putenv( char* str );
        //-- str 为 形式为 name=value 的字符串。 将其放入 环境表中
        //-- 如果 name 已经存在，则先删除 其原来的定义。

        //-- 本函数 并不会为 str这个字符串 分配存储空间，而是直接让 环境表中的对应指针指向它。
        //-- 这一实现的 潜在风险是，如果 str 这个字符串是在 函数栈中临时创建的，
        //-- 那么等 函数返回后，这个 字符串就失效了。

        //-- return: 
        //-- 成功，返回 0
        //-- 出错，返回 非0

int setenv( const char* name, const char* value, int rewrite );
        //-- 首先在 环境表中查找是否存在 name 指向的那一项。
        //-- 如果不存在，则添加一项 新的环境字符串，其name设置为 参数name的值，其value设置为 参数value的值。
        //-- 如果 此name指向的项 已经存在，则观察 参数 rewrite： 
        //--    当 rewrite 非0时： 则用 value的值 代替 此环境字符串 中原有的 value值。
        //--    当 rewrite 为0时： 则维持原状，且不报错。

        //-- 与 putenv 不同，本函数 会主动分配存储空间 来存放 新的 环境字符串。

int unsetenv( const char* name );
        //-- 删除 name 指向的那一项。 
        //-- 如果不存在 name那项。则什么也不做，也不报错

        //-- 两个函数 return：
        //-- 成功，返回 0. 
        //-- 出错，返回 -1.


//---------------------------------
//-- 长跳转
#include  <setjmp.h>

int setjmp( jmp_buf env );
        //-- 在希望设置 返回点 的代码位置处， 写下本句语句。
        //-- 参数 env 可以被看作一种 位置标示符，用来区分 本返回点，和其他返回点。
        //-- 实际上，env 的类型为 jmp_buf,是某种类型的数组，
        //-- 它存放 在调用 longjmp 时，能用来恢复栈状态的 所有消息。
        //-- 因为需要在 另一个函数中 引用 env变量。
        //-- 所以 env变量 通常被定义为 全局变量。

        //-- 本函数 通常会被执行 2次 以上。
        //-- 第一次是 顺序执行时，本函数会 登记 env。将本语句的 信息 写入 env变量中。
        //-- 第二次是 其他函数中的 longjmp执行时， 跳回 本函数地址处，会再执行一遍本函数。
        //-- 此时，本函数 会将 longjmp中的 函数2:val 返回出来。实现一种 值的传递。

        //-- return:
        //-- 若 直接调用 本函数，返回 0.
        //-- 若 从 longjmp 返回， 则为 非0. (返回的值 是 longjmp 中的 参数 val)

void longjmp( jmp_buf env, int val );
        //-- 根据 参数 env，跳转到 对应的 setjmp语句处。
        //-- 然后会再执行一遍 setjmp,然后将 本函数的 参数 val  返回出去。
        //-- 参数 val 被传递到了 setjmp 所在的函数中。
        
        //-- 本函数 会 实现 不同函数间的跳转。目的地通常是 一个较浅的栈帧（早于本语句所在函数的 函数 ）
        //-- 这种回跳，会把 目的地栈帧 下方的所有 栈帧 都丢弃掉。
        //-- 但是 并不保证 会 回滚所有的 变量的值。
        //-- 这意味着，虽然 longjmp 跳回了 目标语句地址处，但并不是彻底的 时光倒流。

        //-- 有些变量 在编译器优化之后，可能存储在 寄存器内，这类变量 将受到 longjmp 的影响。
        //-- 它们会 回滚到 目标语句地址处 的状态。

        //-- 如果希望一个变量 在执行 longjmp 之后，仍保持 执行 longjmp 前的值（也就是最晚时刻的值）
        //-- 需要为其 添加 volatile 关键词。
        //-- 此关键词 将 要求 编译器 不优化 此变量。每次访问它，都直接从其 原始地址处 读写。

//---------------------------------
//-- 查询 和 修改 进程的资源限制
//-- 具体见 APUE -- p176
#include  <sys/resource.h>

int getrlimit( int resource, struct rlimit* rlptr );

int setrlimit( int resource, const struct rlimit* rlptr );

        //-- return:
        //-- 成功，返回 0. 
        //-- 出错，返回 非0. 










#endif

