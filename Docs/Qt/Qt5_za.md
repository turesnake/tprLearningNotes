[ZA]_Qt5
----------  Qt widgets部分知识点整理


-------------------------------------------------------

QtCoreApplication 生成一个无UI的事件循环，在控制台中呈现窗口部件

QtApplication 创建 带有UI图形界面的 事件循环
	需要在pro文件中添加：
	QT += widgets

---------------------------------------------------------
<- 自动创建 成员函数的 定义／声明 ->

在自定义的 h文件中，单击类成员函数的名字，此时成员函数的名字被红框包围
然后按下： Alt + Enter 按键
弹出对话框选择
可以直接跳转到相应的 cpp文件 自动创建此函数的定义

反向亦可以。


-------------------------------------------------------
<- 重命名refactor 函数名／变量名 ->

右键单击 函数名／变量名 -
选择： refactor
选择 xxx   或快捷键： ctrl + shift + R
在下方 替换框中输入 新名，
单击 “替换”

---------------------------------------------------------

<- qt源码位置 ->
- Qt5.7.1
- 5.7
- Src  (这里的就都是源码了)
- qtbase
- include (所以可以 #include 吗？)但是这里面时没有源代码的，只有链接
= src (这里的才是真正源码)
- 


----------------------------------------------------------

<- 什么是:"QT_BEGIN_NAMESPACE" ->

//qglobal.h

#define QT_BEGIN_NAMESPACE namespace QT_NAMESPACE {

#define QT_END_NAMESPACE }

//----

QT_BEGIN_NAMESPACE

class QAction;
class QMenu;
class QPlainTextEdit;

QT_END_NAMESPACE

//在编译时会变成：

namespace QT_NAMESPACE
{
	class QAction;
	class QMenu;
	class QPlainTextEdit;
}

//QT_NAMESPACE  是qt自己定义的 命名空间

//仅当在编译qt时，加上 -qtnamespace 选项时，这两个宏才会有作用
//这时，qt作为第三方库，要使用用户自定义的命名空间来访问qt中的类



--------------------------------------------------------

<- Qt::something ->

这里的Qt 是一个namespace，不是类


---------------------------------------------------------

<- QApplication 和 QCoreApplication 的区别->

-- QApplication
	qmake： QT += widgets

-- QCoreApplication
	qmake: QT += core

两者的继承关系：
QObject --> QCoreApplication --> QGuiApplication --> QApplication


---------------------------------------------------------

<- signal 信号函数 slot- 槽函数->

信号就是一个 函数名， 返回值是 void （因为无法获得信号的返回值，所以无需返回值）

函数的参数 就是 需要让外界知道的 数据。

信号作为函数名，不需要在cpp函数中添加任何实现（空的就行，大括号都不用）
moc会帮我们实现信号函数所需的函数体

emit 是对c++的扩展，是一个关键字，其实也是一个宏。

emit newpaper(m_name);
// 将newpaper 这个信号函数发射出去。将m_name作为参数传递给这个信号。
//当相应的接受者 连接到这个信号，就可以通过槽函数 获得 实际值。
//从而完成 数据 从发出者 到 接收者 的转移

所以，信号槽的实质 就是 如何在不同的函数间 传递参数。

QT5中，任何成员函数，static函数，全局函数 和 lambda表达式 都可以作为 槽函数。

槽函数需要自己完成实现（定义）。

可以把槽函数看成普通的成员函数。 也会受到public，private等访问控制符的影响。

（事实上信号函数也会，但是如果信号函数是private的，这个信号就不能在类之外连接了。也就没意义了）


信号槽的 实践：

首先用 QObject::connect 函数 连接 好信号和槽（想想成放置好炸弹）

然后在何时的地方执行 emit函数，也就是发出信号启动令。 从而引爆 信号槽反应，

---

由于信号槽的实质就是，传递一个参数给信号函数， 然后希望这个参数能传给 槽函数。
所以。信号函数 和 槽函数的 参数类型应该是一致的。

信号的释放过程是 阻塞的。只有当反应槽 执行完毕后，该信号释放过程 才返回。
如果一个信号和多个反应槽链接。则这些反应槽将被顺序执行。排序过程是任意的。
因此如果程序中对这些反应槽的先后执行次序有严格要求的， 应该注意。

信号的定义过程是在类的定义过程中 即头文件中实现的，
为了中间编译工具 moc的正常运行， 不要在源文件cpp中定义信号。

也可把反应槽定义成 虚函数 以便之类进行不同的实现，

Q_OBJECT宏
作用有两个：
- 对与自己相关的QMetaObject中间类操作进行声明，
- 对信号的释放操作 和 反应槽的 激活操作进行声明。

----
在qt4中，槽函数必须放在slots修饰的代码块中，
并且要使用 访问控制符 进行控制。

-------------------------------------------------------------



























-end-