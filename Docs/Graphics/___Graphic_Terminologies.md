零散的 图形学 专业术语


# ---------------------------------------------- #
#             punctual light
# ---------------------------------------------- #
（punctual：准时）但是 本术语 和 时间无关：

punctual light 表示：   
    精确光源
    拥有一个确定位置的 点光源
    
这是一族光源的集合：
    point light - 点光源，向四周均匀发射光线
    spotlight   - 聚光灯，在一个夹角内发射光线
都属于它。



# ---------------------------------------------- #
#          dependent texture read   
# ---------------------------------------------- #
《rtr》 p-177

这个术语有两种含义：


（1）针对 移动GPU：
    读取 texture 需要纹理坐标(texture coordinates)
    只要是 
        “不直接使用 由 vs传入的，现成的 纹理坐标，而是在 fs 中手动计算一个的行为”
    就叫 dependent texture read。
    ---
    这个含义很广泛，比如，拿着 vs传入的 纹理坐标，然后简单 swap u，v值，这种操作也算。
    ---
    上述操作，在 老的 移动GPU 中是使用受限的。老的移动GPU，读取默认的 纹理坐标，速度会更快。


（2）针对 旧桌面GPU：
    “本次 texture 读取，所依赖的 纹理坐标。是由本 fs 代码中的 前一次纹理读取得到的值，决定的”
    就叫 dependent texture read。
    ---
    老的 桌面GPU 可能直接不支持这种操作。
    如今的GPU 支持这种操作，但它仍会影响性能



# ---------------------------------------------- #
#              alpha 系列术语
# ---------------------------------------------- #

# ---
alpha test / alpha cutout
    透明剪切
	    if (frag.alpha < threshold){ discard; }
    通过的frag，透明度被设为 1
    不通过的，透明度被设为 0
    ---
    优点
        * 不需要为渲染objs排序，就能实现 像素级的正确层叠顺序
            类似 cross-tree，用两个面片交叉实现的树，这两个面片就是相互穿透的，
            几户无法为这两个面片 确定 前后顺序，（进而正确使用 alpha blend）

    缺点
        * 只能做二极区分，不存在半透明值
        * 当 texture 被缩小后，出现问题：
            如果使用 常规mipmap，缩小图中的 半透明值，往往是不正确的
            （一个像素的透明值，是上一层的，4个像素的 透明值的平均值）
            这会导致 各层缩小图 变得越来越 “半透明”
            《rtr》p-204 介绍了解决方法
        * 当 texture 被放大后，出现问题：
            原来的像素边界，变成了 波纹伪影/ripple artifacts



    ---
    cutout 是否属于这类，还是另一种单独类型，有待进一步学习

# ---
Dither
    去掉一部分像素来模拟半透明效果
    类似纱窗的效果（参考mhw）
    

# ---
alpha blend
    透明混合
	要考虑渲染顺序（先实心后半透明，先远后近）
	关闭 zWrite, 半透明物的 z值，不会写入 z-buffer
	要指定 blend状态，blend因子

# ---
alpha to coverage
    原理：
    设每个frag，采样8次。运行 fs，可得到此frag 的 alpha值。
    将这个值，看作是 "采样的有效次数（覆盖次数）"
        take the transparency value of the fragment 
        and convert this into how many samples inside a pixel are covered.
    假设那个 alpha换算下来，是：“8次采样覆盖了2次”。
    那么就在后续的 msaa 过程中，只执行2次采样（剩余的6次全部丢弃）
    以此来获得一个 最终颜色值。
    而且，这个值是实心的，所以可以无关 objs渲染顺序。
    ---
    缺点：
        当出现大量半透明像素，相互重叠时，此方法会导致大量的 aliasing 
    


# ---
addtive / AD
    透叠
    表达辉光体，



# ---------------------------------------------- #
#              scattering  
# ---------------------------------------------- #
散射
《rtr》p-297

（反射 是 散射 的特殊形式）

# ---

光波撞击到小型颗粒（particles），就会引发散射。
这些小型颗粒，包含：单独一个分子，或 若干分子聚合成的小微粒（直径小于广波长）

# ---
随着分子的不断聚合，小型微粒的尺寸越老越大，此时发生的散射光的强度也会逐渐增强。
直到 微粒的尺寸 超过广波长（此后散射光的强度停止变强）

# --- 云，雾
这也是为什么 云，雾 拥有非常强的 散射光，因为它们的组成颗粒是 小水珠。
这些水珠的直径，和光波长相似。

# --- Rayleigh scattering
瑞利散射   
    《rtr》p-298
    ---
    现象：天蓝光。
        大气中的微小颗粒（直径小于光波）散射了太阳光：
        短光波（红）更容易被散射
        长光波（蓝）更容易被保留

# --- Tyndall scattering
丁达尔散射  
    《rtr》p-298
    ---
    现象：牛奶。

# --- Mie scattering
米氏散射    
    《rtr》p-298
    微粒波长已经超过 光波长
    散射波在整个微粒上 不再 同向，这改变了散射的性质。
    散射越来越倾向于正向，波长依赖性降低，直到所有可见光波长的光被均匀散射。
    ---
    现象：黄昏天色。
        此时低空大气中的 大颗粒，散射了光



# ---------------------------------------------- #
#           specular  -  diffuse
# ---------------------------------------------- #

# --- specular
表面发生 直接反射 的强度

# --- diffuse
表面发生 局部次表面散射 的强度 local subsurface scattering







