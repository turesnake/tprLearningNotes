# ----------------------------------------------#
#             blendr script
# ----------------------------------------------#

一种学习 blender script 的绝好办法：
在交互界面上执行一个操作
然后看其 console，上面会自动显示，这条操作，对应的脚本语句



# ======================================================= #
#      如何在 blender 中使用 操作系统 全局 path 中的 module
# ======================================================= #

如果直接在 blender text editor 中打开一个 .py 文件, 这个文件内大概率索引不到 操作系统全局 python path;

# -1- window11 中设置好 python 全局 path, 在你自己的 全局库目录 准备好 .py 文件

# -2- 在 脚本文件头部写:
import sys
sys.path.append(r"E:\python_2_modules")  # 或 insert(0, "...") 优先


# -3- 然后这个脚本就能索引到 指定目录内的文件了...









# ----------------------------------------------#
#                    ZA
# ----------------------------------------------#
-- alt+p 运行脚本

-- alt+s 保存当前文档(前提是要先 创建这个文档)

-- 在 win 中使用路径名时，'\' 全部改成 '\\'
	或者直接使用 "/"


# ----------------------------------------------#
#         切换 Edit / Object 模式
# ----------------------------------------------#

bpy.ops.object.mode_set(mode='OBJECT') # 进入 obj 模式
bpy.ops.object.mode_set(mode='EDIT')
...




# ----------------------------------------------#
#             render outPath
# ----------------------------------------------#
-- 设置渲染路径
	bpy.context.scene.render.filepath = "C:\\aaa\\bbb\\"
	---
	如果路径是一个 目录名，且需要渲染的图有不只一张
	blender，会自动按数字命名

--- 推荐的方案是，手动设置 每一帧的 文件名（包括，手动写序号）


# ----------------------------------------------#
#             render and save
# ----------------------------------------------#
-- 渲染一个 anim action frmaes, 并且保存进目标文件中
	bpy.ops.render.render( animation=True, write_still=True )

-- 如果并不想渲染动画，应将参数 animation 设为 false


# ----------------------------------------------#
#            找到 目标 obj
# ----------------------------------------------#
obj = bpy.context.scene.objects["objName"]


# bpy.ops.object:
用户点击菜单、按钮、快捷键后触发的指令。
通常触发一些较为复杂的行为，比如切换模式、添加物体、应用变换等。

# bpy.context.object
当前上下文（Context）里被激活的物体（active object），即在界面中最被关注、处于激活状态的那个物体。






# ----------------------------------------------#
#      如何让 obj 在渲染时隐藏
# ----------------------------------------------#
obj.hide_render = True
	-- 让目标obj 在渲染时隐藏

-- 此外，也可在 面板中实现：
	outliner: 可以选择显示 camera icon
	它就是用来控制 是否在渲染时显示的
	这个 icon 默认是关闭的，需要手动开启


# ----------------------------------------------#
#       暂存 obj 原始数据
# ----------------------------------------------#
比如说，修改之前的 rotation 数据

obj.rotation_euler
	一个可读可写的数据，array[3]
	在python中，记得用 复制，而不是引用 暂存它


# ----------------------------------------------#
#             移动 obj
# ----------------------------------------------#
--1--
先 选中目标obj

--2--
bpy.ops.transform.translate( value=(1.0, 2.0, 3.0), orient_type="GLOBAL" )
	基于当前pos，执行一次位移

-------
更简单的方法：
直接设置 location
obj.location
	一个可读可写的数据，array[3]
	它的值，就是界面中，obj.Location 的值


# ----------------------------------------------#
#             移动 obj
#             旋转 obj
#             缩放 obj
# ----------------------------------------------#
最最简单的方案：
一个可读可写的数据，array[3]

obj.location
obj.rotation_euler
obj.scale



# ----------------------------------------------#
#           复制 obj
# ----------------------------------------------#
--1--
选中 目标obj "cube"

--2--
bpy.ops.object.duplicate_move(
	OBJECT_OT_duplicate={"mode":"TRANSLATION"},
	TRANSFORM_OT_translate={"value":(x,y,z)}
)
	---
	参数2 中的 xyz，是位移偏移值，不是新obj 的绝对坐标

--3--
bpy.context.object.name = "new"
	---
	在复制出新的 obj后，新obj 的名字是 blender 自动生成的
	我们立刻将其改为我们需要的名字


# ----------------------------------------------#
#           修改 obj name
# ----------------------------------------------#
--1--
先 选中目标obj

--2--
bpy.context.object.name = "new"


# ----------------------------------------------#
#           创建 new obj： curve
# ----------------------------------------------#

bpy.ops.curve.primitive_bezier_circle_add(
	radius=1, 
	enter_editmode=False, 
	location=(0, 0, 0)
)
	---
	我们常使用 curve 来制作 控制器。














