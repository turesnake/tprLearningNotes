# ================================================================ #
#                   切线空间 （ TBN空间 ） [右手坐标系]
#                   tangent Space
# ================================================================ #


曲面（模型）上的一个点，以自身为原点，建立一个 切线坐标系：

#    X轴 Tangent:   是 此点在 UV坐标系中的 U轴方向
#    Y轴 Binormal: = cross( z,x ); (注意参数顺序) 此点在 UV坐标系中的 V轴方向
#    Z轴 Normal:    是 曲面法线方向
    ----
    xyz 三轴 关系符合 右手定则

为了便于记忆，我们称这个空间为 TBN空间 （对应 xyz 轴）


当某个点的 法线向量没有 扰动时，它记录在 法线贴图中的数据应该是 (0, 0, 1.0, 1.0)
解释起来就是：xy轴值都为0，z值为1，整个 法线向量，是个 单位向量。


# +++++ 切线空间可视化 +++++++ #
可使用同目录文件: TangentSpaceVisualizer.cs 来显示 各个顶点的 切线空间信息;



# ======================================================= #
# 如何将 normaldir 从 tangent-space 转换到 WS ？
# ------------------------------------------------------- #
# :
    和 fenglele 书中的实现一样：
        float3x3 mat = float3x3( tangentWS, binormalWS, normalWS ); // 是目标矩阵的转置
        float3 out = mul( in_, mat ); // 这里是左乘
    注意，在这个实现中，装配的 矩阵， 是目标矩阵的 转置矩阵
    因为从 float3x3() 构造器写入得三个向量, 是三个 row !!!

    因此，第二步的 mul() 计算中，使用的是 左乘


# 核心思路
使用 world-space 坐标值, 去描述 切线空间中的 三个轴向量,
将 切线空间内的 向量 与这个 "描述" 相乘, 就能获得 world-space 中的表达;


# ======================================================= #
#    如何通过 normal 和 tangent 计算 binormal 
# ------------------------------------------------------- #

float3 binormal = cross( normal, tangent.xyz ) 
                    * tangent.w
                    * unity_WorldTransformParams.w;

# 注意: 
#    这个计算发生在 world-Space 中 !!!!!!!!


# unity_WorldTransformParams.w
如果物体所在的 层次结构中, 每一层的 transform.scale<0 的次数为奇数个, 此 w 值为 -1;
也是为了修正 切线空间的方向用的;


# ======================================================= #
#     tangent.w 为何大部分时候为 -1, 偶尔则为 1
# ------------------------------------------------------- #

首先:
# cross( normal, tangent.xyz ) 是发生在 "World-Space" 中的 !!!!!!!
    尽管 切线空间自己为 右手坐标系, 但实际代码中, 计算 binormal 时,
    用的却都是 ws 中的值,
    
    而 ws 是左手坐标系;
    在 左手坐标系中, YxX = -Z; 即: NxT = -B;
    
    所有需要再乘以 -1, 将 binormal 反向一下;

# 所以, 对于绝大部分 mesh 的顶点, 它的 tangent.w 值都为 -1;

# ------------ #
但有些模型是左右对称的, 这些模型实际上只存储了半侧的顶点信息, 另一侧是翻转得到的;
算是某种 数据压缩;

当这种模型导入 unity 后, 为了支持另一侧的 顶点也能获得正确的 切线空间, 
那些顶点的 tangent.w 值就是 1;




# ======================================================= #
#         mikktspace 标准
# ------------------------------------------------------- #
unity 5.3 开始, 使用 mikktspace 来管理模型的 法线生成, 切线空间规则, ts<->ws 转换规则等;
所以, 确保你的 3d软件也使用 mikktspace;

mikktspace 是 切线空间 和 法线生成 的一套标准;
此标准要求:

    需在 vertex shader 中获取 归一化的 法线和切线, 
    然后这些 法线切线, 会在 vertex shader -> frag shader 过程中被 插值到每个 fragment 中,
    然后在 frag shader 中, 使用未归一化的 法线切线,执行:
        cross(normal.xyz, tangent.xyz) * tangent.w
    计算出 binormal, 

catlike built-in rendering 中的实现, 和 unity standard shader 中的实现, 都符合此标准;

    一个区别是, catlike 选择在 frag shader 中计算 binormal, 
    unity built-in 选择在 vertex shader 中计算 binormal;

    当然, 这两种方式得到的结果是 有细微不同的; 




# ======================================================= #
#     tpr:   切线方向 怎么定
# ------------------------------------------------------- #
其实切线信息 不会被存储在 fbx 文件里, 

# 切线方向 是基于 uv 坐标计算出来的,

# 如果发现 切线方向不是自己想要的, 可通过翻转 uv 来实现




