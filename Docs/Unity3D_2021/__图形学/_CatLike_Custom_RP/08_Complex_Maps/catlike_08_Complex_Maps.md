

# &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& #
#                   Mask Map (MODS)
#  RGBA通道各存储: Metallic, Occlusion, Detial, Smoothness
# ---------------------------------------------------------------- #

# 此 texture 的 sRGB(color texture) 应关闭 !!!

本质就是 4张 mask texturre. 每一张的 texel 存储的都是一个 [0.0, 1.0] 值.
用它来控制 4中数据的 "通过量" (0:完全阻断, 1:完全通过)


# ========= #
# Occlusion:
    [0.0, 1.0]
    直观理解就是 间接光照因子.  值越大, 通过的间接光越多. 


# material property: _Occlusion 
    用此值来 调节整个材质的 occlusion 强度:
        设为 0: 此时 MODS.y 完全有效, 就按它记载的 occlusion 值来算
        设为 1: 此时 MODS.y 完全失效, 所有 occlusion 值全被设为 1. (即:完全不影响 间接光强度)



# ========= #
# Detail:
    [0.0, 1.0]
    控制 Detail Map 的强弱



# &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& #
#                    Detial Map
# ---------------------------------------------------------------- #

# 此 texture 的 sRGB(color texture) 应关闭 !!!

提供比 baseMap 和 MaskMap 尺度更细腻的 视觉细节. 以便在凑近观察时 能看到更丰富的细节,更高分辨率的内容,
而不是 baseMap 颗粒化的细节. 

HDRP 使用 ANySNx 格式:
    -- R:   albedo modulation [0, 1]
            0.5 为基准值, 值更高, albedo 越亮,
    -- B:   smoothness modulation
    -- AG:  detail normal vector's XY  (catlike 中未使用)




# &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& #
#                 法线贴图    切线空间
# --------------------------------------------------------------- #

# =1= NormalMap 存储了啥:
模型的每一个顶点, 都记录了自己的 切线空间信息:
    顶点就是这个 切线空间的 原点. 
    顶点法线 就是 这个空间的 z轴
    顶点还有一个人为规定的切线, 通常为右手方向, 就是这个空间的 x轴
    然后通过 叉乘, 可计算出 Bitangent, 即这个空间的 y轴方向.
    ---
    以上这部分信息, 是由 顶点自己携带的. 分别为:

        float3  normalOS    : NORMAL;
        float4  tangentOS   : TANGENT;

    都是 unity 自动提供给 shader 的.

而 NormalMap 中每个 texel, 存储的就是:
目标 frag, 在它所在的 切线空间中的 法线方向. 

当这个 frag 的法线不做任何扰动时(维持原始法线),
那就在 NormalMap 中记录 (0,0,1).  指向切线空间的z轴.



# =2= 从区间[-1,1] 映射到区间 [0,1]
当然, 直接存储一个 法线向量 是做不到的, 因为向量的每个分量区间都为 [-1,1], 而 texel 的 RGBA 分量值 默认区间为 [0,1], 

所以要对 存入的值 * 0.5 + 0.5;  将其映射到 [0,1] 区间.

反之, 从 texel 中提取的值, 也要做 * 2 - 1; 将其映射回 [-1,1] 区间. 


# =3= 从切线空间 转换到 世界空间
直接从 NormalMap 取出的法线向量, 是位于切线空间的, 需要将其转换进 WS 才能使用.



# ======= DXT5nm 技术:
还有别的存储 法线的 技术:

可选择在 texel 中只存储两个分量, 然后在运行时,用叉乘计算出 第三个分量.  
通常保留 tangent 和 bitengent 两个轴向的分量.

然后,这两个分量值还能被进一步压缩.

通常, 这两个分量信息被存储在 RG 或 AG 通道中.

DXT5nm 就是一种与之类似的 存储技术.

可使用宏 UNITY_NO_DXT5nm 来判断不同平台选择的 实现方式.
进而调用相应的函数



# &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& #
#           规避 条件分支: if branch
# --------------------------------------------------------------- #

注意看教程: 
5. Optional Maps

大概意思如下:

-- 首先, 准备一个 keyword: _KEY

-- 然后是一个变量: bool use;
    此变量只被初始化一次,然后就没有被 修改:
    use = false;

-- 就算有修改,也是封在 宏里面的:

    #if defined(_KEY)
        use = true;
    #endif

-- 最后,写一个函数:

    float foo(){
        if(use=true){
            doSomthing();
            return 999.0;
        }
        return 1.0;
    }

# 按照 catlike 说法, 这个函数中并不会引发 if branch.
    个人猜测:
    因为 变量 use 只在最开始被设置为 false, 之后就没再修改过.
    所以 gpu 编译器优化了此处, 将其修改为一个 const 变量.
    进而规避了 函数中 if语句 引发的 branch 分支.

    













