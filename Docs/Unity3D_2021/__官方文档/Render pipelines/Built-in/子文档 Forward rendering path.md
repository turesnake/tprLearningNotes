# ================================================================ #
#     Forward rendering path   原始文档翻译:
# ================================================================ #
基于 一个物体相关联的 灯光数量，通过 一到多次 pass 渲染这个物体。
基于每个光源的设置和强度，它们被 forward rendering 对待的方式也不一样。


# Implementation Details
一些最亮的 光源 会 逐像素渲染。然后，每个"顶点"(不是像素)最多计算 4个 点光源。剩余的光源被计算为 球谐。
基于以下规则来 调度不同光源：

-- Render Mode 设置为 Not Important 的光源，总是 逐顶点 或 球谐。
-- 最亮的 平行光 总是 逐像素
-- Render Mode 设置为 Important 的光源，总是 逐像素。
-- 按照上述规则，如果获得的 逐像素 光源数量，仍然少于：
    Project Setting - Quality - Rendering - Pixel Light Count 所标记的数量（通常为4）
    那就针对剩余光源，按照亮度高低，将更多光源 选择为 逐像素。


每个对象的渲染如下所示：
-- base pass 实现 一个 逐像素 平行光, 以及所有的 逐顶点/球谐光
-- 剩余的 逐像素 光源 在 additional passes 中被实现, 一次 pass 实现一个光源


[参见文档原图: 一组光源:ABCDEFGH 由近及远 围绕在一个物体周围]
假设这些光源属性都相同, render mode 都设为 auto (还有:Important 之类的选项)

此时,最亮的灯会被设置为 逐像素 (A~D)
然后最多 4 个灯设置为 逐顶点 (D~G)
剩余的灯设置为 球谐 (G~H)

注意,上述三个集合间存在覆盖关系(比如 D 同时存在于 第一组和第二组)
这样一来,当物体或光源 发生移动时,不会出现 "light popping"(光的震荡)

# Base Pass
base pass 用一个 逐像素 平行光 和 所有的 逐顶点/球谐光 渲染物体.

顶点光(仅点光源) 在 vertex shader 中计算

剩余的所有光都会被聚合为单独一份 球谐光, 以每个物体的中心为pos 的球谐光 
然后在 frag shader 中, 拿着自己的 法线, 去计算本 frag 接收到的 球谐光;

这个 pass 也处理任何 lightmaps, 源自 shader 的 遮蔽 和 自发光.
此 pass 处理的 平行光 允许投射阴影.
注意, 使用 lightmap 的物体,无法从 球谐光源 中获得照明.

注意,当在 shader 中使用 "OnlyDirectional" pass flag 时, forward base
pass 只渲染 主平行光,遮蔽/lightprobe, lightmaps
( 球谐 和 逐顶点光 不被包含进 pass data 中 )

# Additional Passes
每个 Additional Pass 实现一个 逐像素 光源. 默认时,这些光源不产生阴影.
(所以, forward rendering 只支持一个 平行光阴影) 

除非使用了 "multi_compile_fwdadd_fullshadows" variant shortcut


# Performance Considerations 性能注意事项

球谐光 渲染速度很快. 它们的 cpu 成本很低, 对于 GPU 来说也近乎是免费的
(bass pass 总是计算 球谐光, 但鉴于球谐光的工作方式, 不管存在多少个球谐光, 此计算的成本 都是相同的)

球谐光的缺点:
-- 它们在物体的 顶点上进行计算,而不是像素. 这意味着它们不支持 light cookies
    或 法线贴图.
    (很奇怪, catlike 中则是在 farg shader 中计算的...)

-- 球谐光 很低频. 只支持 漫反射光照.
-- 球谐光不是 局部的, 靠近某些平面的 点光源,spot光源 如果被表达成 球谐,
    它们的效果看起来会 "不正确".

总之, 对于 动态物体来说, 球谐光足够用了.




# ================================================================ #
#                     个人理解与整理
# ================================================================ #

# -1-: 光源的选择
    必须是 逐物体的, 每一个物体 都会针对自己实现一张 光源强弱排序表;
    以此来决定那些光可以是 逐像素, 那些是逐顶点, 那些是 全部整合为一个球谐

# -2-: 为什么一个 pass, 只能渲染一个光源
    主要是因为在这个 pass 渲染过程中, unity 只准备了一盏光的 信息;
    当然, Base pass 除外, 它还额外准备了 4个 逐顶点光(仅点光源) 的信息, 还有 最终剩余的光源的 球谐信息

# -3-: 球谐光到底在哪计算: vertex shader 还是 frag shader 中 ?
    在官方文档中, 是在 vertex 中, 
    在 catlike 实现中, 是在 frag shader 中, 并将此光当作 间接光的漫反射部分;


# ============================================== #
#      光照计算顺序:
# ----------------------------------------------#
    

# ------------------ #
# -1- 主平行光
    base pass 一定会被执行, 哪怕场景中不存在 平行光, (此时会把每个物体渲成黑色)
    主平行光只有一个, 它不受 Pixel Light Count 的影响;

    光源颜色: _LightColor0;

# ------------------ #
# -2- 逐像素光
    主平行光之外, 每个物体最多可接收 Pixel Light Count 个 逐像素光源
    这些光源的类型可以是 平行光, spot光, 点光源

    光源颜色: _LightColor0;

# ------------------ #
# -3- 逐顶点光
    每个物体还能再接受 4 栈 逐顶点光 (仅点光源), 
    之所以数量为4, 是因为它们被存储在 float4 (xyzw) 中:
        unity_4LightPosX0;
        unity_4LightPosY0;
        unity_4LightPosZ0;
        unity_4LightAtten0;

        unity_LightColor[8] (0~3号) 存储光源颜色;

    可以用 Shade4PointLights() 一步到位计算所有 4 个逐顶点光的信息;

    定义了 keyword: VERTEXLIGHT_ON 的 base pass shader variant 负责 逐顶点光的渲染
    所以, 有必要用 multi_compile 实现此 variant;

    在 catlike 中, 逐顶点光 被存入 间接光.漫反射 部分;


# 重合的光源
    为了让 逐像素计算 - 逐顶点计算 之间存在柔和的过度,
    unity 会将最弱的那个 逐像素计算光, 同时计算它的 逐顶点着色 信息;

# 如果 逐顶点光 少于 4 个会怎样 ?
    unity 还是会计算 4 个 逐顶点光的信息, 只不过那些空位上记录的都是 黑色 (无光照)

    在 Shade4PointLights(), 还是会计算 4 个光的信息, 整体计算量是不变的;


# ------------------ #
# -4- 球谐光
    剩余的所有能影响此物体的光源, 会被统统整合为单个 球谐光;
    即,如果场景中存在很多个 平行光, 那么那些被 "剩余" 的平行光, 也会被计算为球谐光;
    ---
    球谐光可以在 vertex shader 中被提取, 也可在 frag shader 中被提取,
    使用 ShadeSH9() 函数; 




