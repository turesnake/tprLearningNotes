# ================================================================ #
#                 管线源码阅读进度
# ================================================================ #
使用 stack 的机制来罗列需要依次查清的信息;


# GetShadowCoord()
    函数细节


# VertexPositionInputs

    VertexPositionInputs.positionNDC 到底被谁使用了, 怎么用的


# projectedPosition
    搜索:
    float rawDepth = SampleSceneDepth(params.projectedPosition.xy / params.projectedPosition.w);


# SampleSceneDepth()

    网页查找: "Reconstruct the world space positions of pixels from the depth texture"
    是官网文档


# _CameraDepthTexture
    查看它的 创建 和 使用路径

# CopyDepthPass
DepthOnlyPass, CopyDepthPass and CopyColorPass now use OnCameraSetup() instead of Configure() 
to set up their passes before executing 

as they only need to get their rendertextures once per camera instead of once per eye.


# URPProfileId.CopyDepth



# Profiler 窗口得使用 和 简易翻译

Module details panel



# ForwardRenderer.Setup() 
    748

# PostProcessPass
# ColorGradingLutPass


# VolumeManager
# VolumeComponent
# Volume
# VolumeProfile
# VolumeParameter


# RenderSingleCamera
    绘制图解
    550 renderer.Setup()
        可以先不展开, 先把 上层内部 做完

# Setup()  [396,936]
    868


# 搞懂 "_CameraDepthAttachment" 和 "_CameraDepthTexture" 两者的关系

    先查看 DepthOnlyPass, 到底写入了谁;

    "_CameraDepthAttachment" 中的 depth 数据是谁写入的;
    到底是谁写入 它, 取决于几个 render pass 的配置


# 查找 SetRenderTarget() 每个重载, 被谁调用了


重点:
    搞懂    m_CameraColorTarget
            m_CameraDepthTarget
    那堆东西到底是怎么配置的

    检查它们是如何被使用的 

renderer.cameraColorTarget
renderer.cameraDepthTarget
renderer.m_CameraColorTarget
renderer.m_CameraDepthTarget
renderer.m_ActiveColorAttachments
renderer.m_ActiveDepthAttachment

    首先, 这不直接 camera 数据, 而是 renderer 的, 它们到底是怎么来的, 


    SetRenderPassAttachments()

    1259












# ---------------------------------

# SetRenderPassAttachments() 有提到, 
    为什么 depth only pass 绑定的是 color buffer ,而不是 depth buffer;
    有空记得 添加到 对应代码的注释上去;



# LinearToSRGB
    有空看看什么原理

# 学习如何 断点测试和跟踪 unity 中代码 


# depth prepass 怎么看都是要自己计算一遍 每个 frag 的 depth 才行
# 而不是简单地在 渲染完 skybox 之后 复制一份出来;
    是这样吗 ?


# 正式用 cs 文件整理 每一种容器的 使用方式;
    方便快速查阅;

    有必要将 c# 的各种用法 在线记录;


# postprocessing pass 也是一个完整的 pass, 也是要经历全套 vs-栅格化-fs 的
    请问, 在这个pass 中, 要渲染几个物体, 是不是由 camera Cull() 来提供 ?
    比如, 一般就是一个 quad obj,

    在 catlike srp 中, 是通过: cmd.DrawProcedural() 来绘制一个 quad 来实现的;
    这甚至都用不到 camera Cull() 返回值;
    此方法能保证 pass 在 vs 中的开销几乎为零, 而 fs 中则只需处理一个 quad 内的 fragments;


# 搜索一个工具, 可以对比两个代码文件, 查找是否相同, 如果不相同, 查找哪些地方被改写了



# 实现一个 demo, 后处理作用于 游戏场景中, 前景的 ui 不受影响;


# ======================================================== #

color / depth target 都绑定为:


沿用 camera 原本绑定得 color/depth target
        
        
Enqueue: renderFeature.renderPasses 
        
Enqueue: opaque Forward Pass
Enqueue: skybox pass
Enqueue: transparent forward pass
        
return
---------------------


若要创建 color texture, 
就要将 renderer color target 设置为:"_CameraColorTexture"


Enqueue: renderFeature.renderPasses 

生成 renderPassInputs;
汇总所有 active render pass 对 input 数据的需求;
以供后续决策用;


? Enqueue: Main Light Shadow Caster Pass
? Enqueue: Additional Lights Shadow Caster Pass


? prepass{
    Setup + EnqueuePass Depth Normal Prepass 或 Depth Prepass
}

? Setup + EnqueuePass: color Grading Lut Pass


Enqueue: Render Opaque Forward Pass

? Enqueue: Draw Skybox Pass

? Setup + EnqueuePass: Copy Depth Pass


如果 depth prepass 和 depth copy pass 都未执行,
那么 base camera 会主动创建一个 "_CameraDepthTexture", 
并写上默认值: "far plane val";

? Enqueue: Transparent Settings Pass
Enqueue: Render Transparent Forward Pass

Enqueue: On Render Object Callback Pass


在 "BeforeRenderingPostProcessing" 时刻, 
调用所有 "MonoBehaviour.OnRenderObject()" callbacks;


? Enqueue: post Process Passes


调用每个 active render pass 的 OnCameraSetup() 函数;

Setup Camera:

?

重设与本 overlay camera 相关的数据

editor: 绘制线框



