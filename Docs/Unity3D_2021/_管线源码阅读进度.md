# ================================================================ #
#                 管线源码阅读进度
# ================================================================ #
使用 stack 的机制来罗列需要依次查清的信息;


# GetShadowCoord()
    函数细节


# VertexPositionInputs

    VertexPositionInputs.positionNDC 到底被谁使用了, 怎么用的


# projectedPosition
    搜索:
    float rawDepth = SampleSceneDepth(params.projectedPosition.xy / params.projectedPosition.w);


# SampleSceneDepth()

    网页查找: "Reconstruct the world space positions of pixels from the depth texture"
    是官网文档


# _CameraDepthTexture
    查看它的 创建 和 使用路径

# CopyDepthPass
DepthOnlyPass, CopyDepthPass and CopyColorPass now use OnCameraSetup() instead of Configure() 
to set up their passes before executing 

as they only need to get their rendertextures once per camera instead of once per eye.


# URPProfileId.CopyDepth



# Profiler 窗口得使用 和 简易翻译

Module details panel



# ForwardRenderer.Setup() 
    748

# PostProcessPass
# ColorGradingLutPass


# VolumeManager
# VolumeComponent
# Volume
# VolumeProfile
# VolumeParameter


# RenderSingleCamera
    绘制图解
    550 renderer.Setup()
        可以先不展开, 先把 上层内部 做完

# Setup()
    418


重点:
    搞懂    m_CameraColorTarget
            m_CameraDepthTarget
    那堆东西到底是怎么配置的

    检查它们是如何被使用的 

renderer.cameraColorTarget
renderer.cameraDepthTarget
renderer.m_CameraColorTarget
renderer.m_CameraDepthTarget
renderer.m_ActiveColorAttachments
renderer.m_ActiveDepthAttachment

    首先, 这不直接 camera 数据, 而是 renderer 的, 它们到底是怎么来的, 


    SetRenderPassAttachments()

    1259










# ---------------------------------

# SetRenderPassAttachments() 有提到, 
    为什么 depth only pass 绑定的是 color buffer ,而不是 depth buffer;
    有空记得 添加到 对应代码的注释上去;



# LinearToSRGB
    有空看看什么原理

# 学习如何 断点测试和跟踪 unity 中代码 


# depth prepass 怎么看都是要自己计算一遍 每个 frag 的 depth 才行
# 而不是简单地在 渲染完 skybox 之后 复制一份出来;
    是这样吗 ?


# 正式用 cs 文件整理 每一种容器的 使用方式;
    方便快速查阅;

    有必要将 c# 的各种用法 在线记录;


# postprocessing pass 也是一个完整的 pass, 也是要经历全套 vs-栅格化-fs 的
    请问, 在这个pass 中, 要渲染几个物体, 是不是由 camera Cull() 来提供 ?
    比如, 一般就是一个 quad obj,

    在 catlike srp 中, 是通过: cmd.DrawProcedural() 来绘制一个 quad 来实现的;
    这甚至都用不到 camera Cull() 返回值;
    此方法能保证 pass 在 vs 中的开销几乎为零, 而 fs 中则只需处理一个 quad 内的 fragments;


# 搜索一个工具, 可以对比两个代码文件, 查找是否相同, 如果不相同, 查找哪些地方被改写了



# 实现一个 demo, 后处理作用于 游戏场景中, 前景的 ui 不受影响;


# ======================================================== #










