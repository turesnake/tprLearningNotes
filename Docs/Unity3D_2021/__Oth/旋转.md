# =================================================//
#              和 旋转有关的 技巧
# =================================================//
很烦，四元数 和 欧拉角 总是要混用才能解决问题。



# -- 逆时针旋转
	unity 中,沿 xyz 轴, 逆时针是 "正" 的旋转方向, 顺时针是反的


== 欧拉角:
	++ 直观
	++ 可以实现 沿某个轴的无限旋转，比如超过 180度
	-- 会引发 万向节死锁死锁
	-- unity 中的 y轴，是世界坐标系y轴，而不是 local 坐标系
	～～～
	当需要沿着某个轴 无限旋转时，需要用到 欧拉角。


== 四元数:
	一个四元数 表达一个 "旋转的过程": 
		可理解为, 从一个方向向量, 旋转到另一个方向向量 的这个 "旋转过程" 本身. 
	++ 可以搞定 万向节死锁 问题
	-- 不直观
	-- 无法连续旋转，超过 180 度的角是无法表达的，会被折回来
	～～～
	适合实现，从一个方向，到另一个方向 的插值旋转。此时不会导致死锁。


# ---------------------------------------- #
#        unity 中的 y轴旋转 
# ---------------------------------------- #
不管你是修改:
	transform.eulerAngles
	transform.localEulerAngles
	transform.rotation.eulerAngles
其中的 y 轴，始终都是 世界坐标系的 y 轴
---
想要实现 模型沿着自身的 y 轴旋转，使用函数：Transform.Rotate
具体内容见下文


# ---------------------------------------- #
#        unity 中的 万向节死锁
# ---------------------------------------- #
unity 中的 y轴，始终为 世界坐标系y轴。
当 模型的 z轴，指向 -y 方向时，出现 死锁。
---
不管你是修改:
	transform.eulerAngles
	transform.localEulerAngles
	transform.rotation.eulerAngles

结果都是一样的，只要 模型的 z 和 世界的 -y 同方向，就会死锁
======

目前为止，唯一有效的 按轴旋转函数是 Transform.Rotate
想要沿着 模型自身的某个轴旋转，直接设置 Space.self 即可
这个函数会忠实地沿着 参数指向的 轴旋转，而且可以无限旋转（不存在角度值溢出）




# ---------------------------------------- #
#         实现一个 物体的 抖动
# ---------------------------------------- #

	注意，目前这个方法是不安全的

--1-- 最好通过一根 bone 来控制这个 mesh
--2-- 比如，让物体 滚转抖动：
	float off = 0.5f;
	bone.transform.Rotate( Vector3.forward, off, Space.Self );

--3-- 为了实现抖动. off 可以被实现为 三角函数
	off = Mathf.Sin( Time.time * 10.0f );
	---
	这样就能获得一个匀速的抖动。
	还可以通过一个参数来调整这个 三角函数
	比如，抖动周期，抖动幅度。

========
不知是否存在更好的办法，比如直接修改 四元数。


# ---------------------------------------- #
#       让物体沿某个轴旋转
# ---------------------------------------- #
官方推荐函数: 
	Transform.Rotate
	---
	直接作用于一个 transform 对象，针对其某个轴，
	做某个角度的旋转。
	===
	这个函数是安全的



# ---------------------------------------- #
#     如何连续地 先后执行 2次 四元数 旋转
# ---------------------------------------- #
我们希望物体从 坐标系起始位置，先后指向两个 四元数的旋转。
公式:
	retQua = inverse( inverse(l) * r );

四元数的 乘法 并不满足交换律，而且，左侧值要求符合 左手定制，右侧符合 右手定制。
解决方案就是 将 左侧值 做 inverse 处理。
---
这个方案也许可以被推广开，实现 n 个四元数的 依次旋转

# 这个到底是用来干嘛用的 ?????



# ---------------------------------------- #
#    用乘法 叠加 两个 四元数 的旋转  
# ---------------------------------------- #


# --- Quaternion * Quaternion
#     Quaternion operator *(Quaternion lhs, Quaternion rhs);

	两个 四元数 的乘法不满足交换律, 两参数顺序颠倒 得到的结果是不同的. 

	文档说此过程等同于 先执行 lhs 旋转, 再执行 rhs 旋转.

	直观总结就是: 让父级旋转 放 左边, 先执行, 让子级旋转放右边, 后执行. 

	在 catlike 中, 如果存在多个 四元数 的乘法, 会先对 右侧的乘法加括号, 
	让它们先乘. 



# -- Quaternion * Vector3
#    Vector3 operator *(Quaternion rotation, Vector3 point);

	Rotates the point point with rotation.
	---
	将坐标点 point 绕着 原点(0,0,0) 旋转 rotation 后,得到的 新的坐标点. 




# ---------------------------------------- #
#        Quaternion.FromToRotation(...)
#   快速创建四元数: 从一个角度, 旋转到另一个角度
# ---------------------------------------- #
	Quaternion FromToRotation(Vector3 fromDirection, Vector3 toDirection);

非常直观易用



# ---------------------------------------- #
#        Mathf.MoveTowardsAngle(...)
#      有限制的转动一个 角度值
# ---------------------------------------- #
	float MoveTowardsAngle(float current, float target, float maxDelta);

从一个角度旋转向另一个角度, 最大转动速度不能超过 maxDelta,
支持 360度->0度 这个接缝口, 所以很好用

因为实际上这个函数只被调用了一次, 所以一次调用不能真的实现 "从一个角度转向另一个角度的 全过程"
而只是转了 "一帧" (转动幅度还受限了)



# ---------------------------------------- #
#        Quaternion.Slerp(...)
#        Quaternion.SlerpUnclamped()
#        球面插值
# ---------------------------------------- #

# --
	Quaternion Slerp(Quaternion a, Quaternion b, float t);

Spherically interpolates between quaternions a and b by ratio t. 
The parameter t is clamped to the range [0, 1].
( 参数 t 会在函数中被主动 clamp 为 [0,1])

适合在两个 四元数 之间插值

# --
	Quaternion SlerpUnclamped(Quaternion a, Quaternion b, float t);

若能保证 参数 t 就是位于 [0,1] 区间, 则可避免 函数内再次 clamp
可适当节省运算


# ---------------------------------------- #
#        Rigidbody.angularVelocity
#       刚体的 旋转角速度
# ---------------------------------------- #
有时候 rigidbody 在被碰撞后会一直旋转, 此时可以调整 angularVelocity 值
让它慢慢衰减下来

	body.angularVelocity *= 0.7f; 






