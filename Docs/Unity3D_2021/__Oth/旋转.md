# =================================================//
#              和 旋转有关的 技巧
# =================================================//
很烦，四元数 和 欧拉角 总是要混用才能解决问题。

# 经过 catlike 的教程, 我们发现 四元数的使用非常灵活
# 几乎可以代替绝大部分 欧拉角 的使用
	当然, 需要足够的练习...


# -- 逆时针旋转
	unity 中,沿 xyz 轴, 逆时针是 "正" 的旋转方向, 顺时针是反的


== 欧拉角:
	++ 直观
	++ 可以实现 沿某个轴的无限旋转，比如超过 180度
	-- 会引发 万向节死锁死锁
	-- unity 中的 y轴，是世界坐标系y轴，而不是 local 坐标系
	～～～
	当需要沿着某个轴 无限旋转时，需要用到 欧拉角。


== 四元数:
	一个四元数 表达一个 "旋转的过程": 
		可理解为, 从一个方向向量, 旋转到另一个方向向量 的这个 "旋转过程" 本身. 
	++ 可以搞定 万向节死锁 问题
	-- 不直观
	-- 无法连续旋转，超过 180 度的角是无法表达的，会被折回来
	～～～
	适合实现，从一个方向，到另一个方向 的插值旋转。此时不会导致死锁。


# ---------------------------------------- #
#        unity 中的 y轴旋转 
# ---------------------------------------- #
不管你是修改:
	transform.eulerAngles
	transform.localEulerAngles
	transform.rotation.eulerAngles
其中的 y 轴，始终都是 世界坐标系的 y 轴
---
想要实现 模型沿着自身的 y 轴旋转，使用函数：Transform.Rotate
具体内容见下文


# ---------------------------------------- #
#        unity 中的 万向节死锁
# ---------------------------------------- #
unity 中的 y轴，始终为 世界坐标系y轴。
当 模型的 z轴，指向 -y 方向时，出现 死锁。
---
不管你是修改:
	transform.eulerAngles
	transform.localEulerAngles
	transform.rotation.eulerAngles

结果都是一样的，只要 模型的 z 和 世界的 -y 同方向，就会死锁
======

目前为止，唯一有效的 按轴旋转函数是 Transform.Rotate
想要沿着 模型自身的某个轴旋转，直接设置 Space.self 即可
这个函数会忠实地沿着 参数指向的 轴旋转，而且可以无限旋转（不存在角度值溢出）




# ---------------------------------------- #
#         实现一个 物体的 抖动
# ---------------------------------------- #

	注意，目前这个方法是不安全的

--1-- 最好通过一根 bone 来控制这个 mesh
--2-- 比如，让物体 滚转抖动：
	float off = 0.5f;
	bone.transform.Rotate( Vector3.forward, off, Space.Self );

--3-- 为了实现抖动. off 可以被实现为 三角函数
	off = Mathf.Sin( Time.time * 10.0f );
	---
	这样就能获得一个匀速的抖动。
	还可以通过一个参数来调整这个 三角函数
	比如，抖动周期，抖动幅度。

========
不知是否存在更好的办法，比如直接修改 四元数。


# ---------------------------------------- #
#       让物体沿某个轴旋转
# ---------------------------------------- #
官方推荐函数: 
	Transform.Rotate
	---
	直接作用于一个 transform 对象，针对其某个轴，
	做某个角度的旋转。
	===
	这个函数是安全的



# ---------------------------------------- #
#       什么是一次 "旋转" 
# ---------------------------------------- #
"旋转" 是一个过程, 可理解为:
	
	一个 坐标系, 沿某个经过原点的轴,旋转了一定角度.

这个旋转作用于 整个 坐标系空间.

# 一个 "旋转", 可用一个 四元数 来表达



# ---------------------------------------- #
#     如何连续地 先后执行 2次 四元数 旋转
# ---------------------------------------- #
我们希望物体从 坐标系起始位置，先后指向两个 四元数的旋转。
公式:
	retQua = inverse( inverse(l) * r );

四元数的 乘法 并不满足交换律，而且，左侧值要求符合 左手定制，右侧符合 右手定制。
解决方案就是 将 左侧值 做 inverse 处理。
---
这个方案也许可以被推广开，实现 n 个四元数的 依次旋转

# 这个到底是用来干嘛用的 ?????



# ---------------------------------------- #
#    用乘法 叠加 两个 四元数 的旋转  
# ---------------------------------------- #

# --- Quaternion * Quaternion
#     Quaternion operator *(Quaternion lhs, Quaternion rhs);

	两个 四元数 的乘法不满足交换律, 两参数顺序颠倒 得到的结果是不同的. 

	文档说此过程等同于 先执行 lhs 旋转, 再执行 rhs 旋转.

	直观总结就是: 让父级旋转 放 左边, 先执行, 让子级旋转放右边, 后执行. 

	在 catlike 中, 如果存在多个 四元数 的乘法, 会先对 右侧的乘法加括号, 
	让它们先乘. 


# -- Quaternion * Vector3
#    Vector3 operator *(Quaternion rotation, Vector3 point);

	Rotates the point point with rotation.
	---
	将坐标点 point 绕着 原点(0,0,0) 旋转 rotation 后,得到的 新的坐标点. 



# ---------------------------------------- #
#    最省脑的旋转:
#    叠加 额外的旋转
#    quaternion_a = quaternion_new * quaternion_a;
# ---------------------------------------- #

# catlike 最惯用的方法:

quaternion_a 就是我们要处理的对象, 它可以是 ball.localRotation 等已经存在的 "旋转状态"
这些 "旋转状态" 可以是上一帧的,

现在我们要对这个物体, 再叠加一次任意轴向的旋转,  此时就能用此公式.

它可以无限叠加下去


# ---------------------------------------- #
#        Quaternion.Euler(...)
# ---------------------------------------- #
	Quaternion Quaternion.Euler(float x, float y, float z);
	Quaternion Quaternion.Euler(Vector3 euler);

Returns a rotation that rotates z degrees around the z axis, 
x degrees around the x axis, and y degrees around the y axis; 
applied in that order.

将一个 欧拉角向量 表达的 "旋转", 计算为一个 四元数形式.

# 十分常用

# ---------------------------------------- #
#        Quaternion.FromToRotation(...)
#   快速创建四元数: 从一个角度, 旋转到另一个角度
# ---------------------------------------- #
	Quaternion FromToRotation(Vector3 fromDirection, Vector3 toDirection);

非常直观易用



# ---------------------------------------- #
#        Quaternion.Angle(...)
# ---------------------------------------- #
	float Quaternion.Angle(Quaternion a, Quaternion b);

a,b 是两个相互无任何关系的 "旋转", (可理解为球面上的两个方向向量)
此函数计算出 这两个 "旋转" 之间的夹角 


# ---------------------------------------- #
#        Quaternion.AngleAxis(...)
# ---------------------------------------- #
	Quaternion Quaternion.AngleAxis(float angle, Vector3 axis);

沿参数轴 axis, 旋转 angle 角度, 返回 计算得到的 "旋转"; 

参数 axis 的模长 并未在计算中被使用 (可能意味着无需归一化)


# ---------------------------------------- #
#        Quaternion.Dot(...)
# ---------------------------------------- #
	float Dot(Quaternion a, Quaternion b);

两个四元数的 点积, 暂没看到它的用处

# 点积结果越大, 说明两个 四元数代表的 "旋转" 越接近



# ---------------------------------------- #
#        Quaternion.FromToRotation(...)
# ---------------------------------------- #
	Quaternion FromToRotation( Vector3 fromDirection, Vector3 toDirection );

从方向 from 转动到 方向 to, 计算并返回这个 "旋转"

# 很常用

# ---------------------------------------- #
#        Quaternion.Inverse(...)
# ---------------------------------------- #
	Quaternion Inverse(Quaternion rotation);

四元数的 逆, 通常代表一个 "反向的旋转"


# ---------------------------------------- #
#        Quaternion.Lerp(...)
#        Quaternion.LerpUnclamped(...)
#        Quaternion.Slerp(...)
#        Quaternion.SlerpUnclamped(...)
# ---------------------------------------- #
	Quaternion Lerp				(Quaternion a, Quaternion b, float t);
	Quaternion LerpUnclamped	(Quaternion a, Quaternion b, float t);
	Quaternion Slerp			(Quaternion a, Quaternion b, float t);
	Quaternion SlerpUnclamped	(Quaternion a, Quaternion b, float t);

插值函数

-- 
	不带 Unclamped 的版本, 函数内部会主动将 参数 t clamp 到 [0,1];
	带 Unclamped 的版本, 则调用者自己保证 参数 t 位于 [0,1]
	带 Unclamped 的版本 能节省一些不必要的运算

-- 
	不带 S 的版本, 做线性插值
	带 S 的版本, 做 球面插值!!!

-- 
	最终返回的 四元数 会被归一化 
	(其实只在 Lerp 的文档中提到这一点...)


# ---------------------------------------- #
#        Quaternion.LookRotation(...)
# ---------------------------------------- #
	Quaternion LookRotation( Vector3 forward, Vector3 upwards = Vector3.up );

提供一个 forward 方向, 一个 up 方向, 返回一个 对应的坐标系, 用四元数表达.
此四元数也可理解为:
	从 ws 坐标系, 旋转到这个新坐标系, 的 "旋转" 本身.

-- 
	若 forward, up 任一模长为0, 返回 Quaternion.identity
--
	若 forward, up 共线, 返回 Quaternion.identity


# ---------------------------------------- #
#        Quaternion.Normalize(...)
#        Quaternion.normalized
# ---------------------------------------- #
	Quaternion Normalize(Quaternion q);

# 注意!!! 此函数会把 参数 也归一化 !!!
# 若不想影响参数, 可使用: Quaternion.normalized; 这个 property

--
	不管使用哪一种, 若参数模长过短, 都只会返回 Quaternion.identity



# ---------------------------------------- #
#        Quaternion.RotateTowards(...)
# ---------------------------------------- #
	Quaternion RotateTowards( Quaternion from, Quaternion to, float maxDegreesDelta );


从 "旋转"from, 过渡(旋转)到 "旋转"to, 同时控制过度速度, 确保单次调用本函数, 
过度的旋转速度不超过 参数 maxDegreesDelta

# Negative values of maxDegreesDelta will move away from "to" 
# until the rotation is exactly the opposite direction.

	没看懂, 和 参数 maxDegreesDelta 取负 有关.

	猜测是 从 from, 朝向远离 to 的方向运动, 直到完成相同夹角的 "反向旋转"

# 很常用


# ---------------------------------------- #
#        Quaternion.operator ==
# ---------------------------------------- #

判断方式:
	两个四元数的 点积 是否接近 1.0

# 注意:
	一个四元数可表达的 旋转区间: [0,720],
		(因为单纯四元数运算,会连续旋转两次, 如果一次为 360度, 那么两次就是 720度)
	
	所以有时 两个四元数看起来是相同的, 很可能一个转了半圈, 一个转了一圈半,
	此时, 这两个四元数 将被判定为 "不相同"




# ---------------------------------------- #
#        Mathf.MoveTowardsAngle(...)
#      有限制的转动一个 角度值
# ---------------------------------------- #
	float MoveTowardsAngle(float current, float target, float maxDelta);

从一个角度旋转向另一个角度, 最大转动速度不能超过 maxDelta,
支持 360度->0度 这个接缝口, 所以很好用

因为实际上这个函数只被调用了一次, 所以一次调用不能真的实现 "从一个角度转向另一个角度的 全过程"
而只是转了 "一帧" (转动幅度还受限了)






# ---------------------------------------- #
#        Rigidbody.angularVelocity
#       刚体的 旋转角速度
# ---------------------------------------- #
有时候 rigidbody 在被碰撞后会一直旋转, 此时可以调整 angularVelocity 值
让它慢慢衰减下来

	body.angularVelocity *= 0.7f; 






