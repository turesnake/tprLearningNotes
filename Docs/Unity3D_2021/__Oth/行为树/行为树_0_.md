


# 行为树 + 黑板系统
黑板系统（Blackboard）:
​​定义​​：一个​​全局共享的数据存储库​​，所有行为树节点均可读写其中的数据。
    → 类比：办公室里的公共白板，任何人可记录/查看信息（如玩家位置、怪物血量、天气状态）。
​
​核心作用​​：分离​​行为逻辑​​（行为树节点）与​​环境状态​​（黑板数据），避免节点间硬编码依赖。





# 行为树: 节点类型​​:
a. ​​控制节点（Control Nodes）​​: 决定子节点的执行顺序，常见的有：
- ​​选择节点（Selector）​​: 按顺序执行子节点，直到有一个子节点执行成功（类似OR）。
- ​​序列节点（Sequence）​​: 按顺序执行子节点，直到有一个子节点执行失败（类似AND）。
- ​​并行节点（Parallel）​​: 同时执行所有子节点，根据条件决定成功或失败。
- ​​装饰节点（Decorator）​​: 对子节点进行条件判断或修饰（例如：重复执行、条件判断等）。 

b. ​​条件节点（Condition Nodes）​​:
- 检查游戏世界中的条件（如“玩家在视野内？”、“生命值低于30%？”）并返回成功或失败。
- 不会改变游戏状态，只做查询。 

c. ​​行为节点（Action Nodes）​​:
- 执行具体的动作（如“移动”、“攻击”、“逃跑”）。
- 这些节点会改变游戏状态，并且可能需要一定时间完成（不是瞬间完成）。


# 执行流程​​:
行为树从根节点开始执行，按照节点逻辑向下遍历。
节点返回三种状态之一：成功（Success）、失败（Failure）、运行中（Running）。
    成功/失败：表示节点执行完毕。
    运行中：表示该节点还在执行（如一个持续3秒的动作），需要下一帧继续执行。

# 实例说明（怪物AI）​​:
一个简单的怪物可能的行为树分支如下：
    选择节点（Selector）作为根节点：
        条件节点：生命值低于20%？如果为真，执行逃跑动作。
        序列节点（Sequence）：
            a. 条件节点：玩家在视野内？如果为真则继续。
            b. 行为节点：向玩家移动。
            c. 行为节点：攻击玩家。
        行为节点：巡逻（当以上都不满足时执行）。


# 优势​​:
    结构清晰，易于扩展和调试。
    节点可复用。
    可以处理长时间执行的动作（返回运行中状态）。
    可以设计复杂的AI行为。

# ​​注意事项​​:
    避免行为树过于庞大，可分层设计（如将一部分子树独立）。
    注意性能，避免每帧遍历整个树（可通过运行状态节点减少遍历）。
    在行为节点中实现协程或状态机以处理连续动作（如攻击动作的起手、持续、收招）。



# ===================================== #
#      相关插件
# ===================================== #


#  flow canvas   里好像有行为树

#  Behavior Designer 
    ai说是付费插件里最强的



# ===================================== #
#      各种缺点:
# ===================================== #

# --- 事件驱动响应：​​ 
行为树本质上是​​轮询驱动​​（Tick-driven）。节点在Tick时检查条件并执行。对于需要​​立即响应​​外部事件（如被攻击、重要物品被拿走）的行为，需要在Tick里持续检查相关事件/条件，或者在架构层面配合事件系统（如通过黑板监听事件），但不如专门的事件驱动架构响应迅速和直接。



# --- 性能问题（设计不当时）：​​
​​Tick 开销：​​ 行为树需要在每个AI实体上（通常是每帧）从根节点Tick整个树（或当前运行路径）。设计不良的树（节点过多、频繁的昂贵条件检查）会导致性能瓶颈。优化需要仔细设计节点（避免高频高开销检查）并利用树的层次结构提前终止（Selector成功或Sequence失败）。
​​
高并发度高：​​ 大量使用 Parallel 节点会导致每个Tick需要访问更多的节点，增加计算量。

​​内存占用：​​ 每个行为树实例（尤其复杂的树）以及其运行时保存的状态（Running节点栈、黑板实例等）会占用一定内存。大量AI实例时需要考虑内存开销。



# --- 数据管理问题：​​
​​黑板滥用与耦合：​​ 黑板（Blackboard）是节点间共享数据的关键机制。但滥用黑板，把所有数据都丢进去，会导致数据管理混乱、节点间隐式依赖增加、耦合度升高。
命名空间规划不好也会导致冲突。

​​数据共享与作用域：​​ 在需要多个子树共享数据，或者区分全局/局部数据时，黑板的设计需要额外小心。动态创建/销毁的AI实体的黑板管理也需要额外考虑。
asdasd

#  状态序列化
如果需要保存/加载AI的状态（如保存游戏），需要序列化行为树当前的执行状态（主要是哪些节点处于Running状态及它们内部的临时状态）以及黑板内容。这比序列化状态机的当前状态要复杂得多。

# ​​学习曲线与设计门槛：​​
​​概念理解：​​ 虽然基本节点（Selector/Sequence/Decorator/Action）容易学，但要​​设计好​​一个清晰、高效、可维护、可扩展的行为树结构，需要深刻理解其执行流程（如记忆特性、Tick顺序）、中断机制、节点职责划分、数据流等，这需要一定的经验积累和设计能力。不良的设计很快会让树变得无法维护。


# !!!!!!!!!! 节点设计粒度：​​ 
叶子节点（特别是Action）的​​粒度​​拿捏很重要。节点太细（如MoveForward1cm）导致树过于冗长；节点太粗（如ExecuteCombatStrategy）则封装了过多复杂逻辑，失去了行为树的模块化和可读性优势。


# 对于状态定义明确、转换清晰、状态间互斥性强且需要明确状态标识的情况，
状态机（FSM 或 HFSM）可能更合适或需要与行为树结合（行为树管理更高层决策，FSM管理具体状态）。


# 对于需要极端性能（海量简单AI）或强事件驱动响应的情况，
更简单的事件+状态系统或专门的解决方案（如基于Utility的AI）可能更高效。


# 在实际项目中，常常见到行为树​​与其他技术结合使用
​​（如：行为树作为高层决策，底层使用状态机管理动画；行为树利用黑板订阅事件系统驱动响应）来弥补各自的不足，发挥最大效益。理解行为树的优缺点，才能更好地运用


# ---------------------------------- #
#      <只狼> 是否用了 行为树
# ---------------------------------- #

# === 明确的行为优先级：​​ 
游戏中可以看到AI在不同情况下果断切换行为，比如放弃未完成的攻击组合去执行一个紧急闪避或招架，这就是优先级抢占的典型体现，行为树的打断机制对此处理得非常自然。


# === 组合与分支行为：​​ 
Boss的攻击模式通常不是简单的循环，而是根据玩家位置、自身状态选择不同的攻击“套路”（可能是多个攻击动作的组合序列），这种结构用行为树的节点组合（选择器Selector、序列器Sequence、并行器Parallel等）很容易搭建。

# === 对玩家输入的即时响应：​​ 
AI能在玩家按下一个攻击键的极短时间内选择最合适的应对方式（如抬手格挡、后撤步反击、危字突刺），这需要决策树能够迅速评估条件并执行相应动作（行为树的层级搜索具备这种能力）。



# ========================================== #
#          行为树 + 事件触发模式
# ========================================== #
将传统行为树与事件触发模式结合，是构建​​更实时、更响应式、更高效​​游戏AI的常见优化手段。行为树的本质是​​轮询检查（Polling）​​，它通过在每个Tick不断自顶向下遍历树节点并检查条件来决定做什么。而事件触发模式则是​​中断驱动（Interrupt-Driven）​​，当特定事情发生时（如玩家进入视野、受到攻击、环境改变）主动通知AI系统。




# ========================================== #
#               优化
# ========================================== #

# -- 滥用条件节点​​
❌ Conditional -> Action 链式结构
✅ 合并为Action内联条件判断
---
和我们预想的相似

# -- 深层次树结构​​
超过5层的嵌套树应拆分为独立子树

# -- 动态创建行为树​​
运行时new BehaviorTree() → 必须用对象池复用















