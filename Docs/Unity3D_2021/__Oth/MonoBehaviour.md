# ================================================================//
#                      MonoBehaviour
# ================================================================//



# ---------------------------------------------- #
#             Awake()
# ---------------------------------------------- #
类似于 constructor 构造函数
会在本类的 成员 被新建完毕后,调用


# ---------------------------------------------- #
#             OnEnable()
# ---------------------------------------------- #
-1-
在 play mode 中, 当一次 "重编译" 发生时, 首先, 所有 active 的组件全部被 disabled, 
此时会调用 OnDisable(), 
然后存储 game state, 执行编译, 然后恢复 game state, 
然后把之前为 active 的 组件全部恢复为 active,

-2-
当一个组件执行了自己的 MonoBehaviour.Awake(); 只会, 也会立即执行 OnEnable();
除非这个组件被存储为 disabled 状态, 


本组件每次在 editor 中热更新后 (也包括 刚启动的 Awake() 时),
进入 enable 状态的一瞬间, 会调用此函数


# ---------------------------------------------- #
#             Reset()
# ---------------------------------------------- #



# ---------------------------------------------- #
#             Start()
# ---------------------------------------------- #
只有在 本组件的 Update 函数被 第一次调用之前, Start 函数才会被调用
(无论这个 组件是否有 update 函数)
如果一个 组件在运行时的某一时刻被新建, 它的第一个 update 会在下一帧被调用. 


# ---------------------------------------------- #
#             FixedUpdate()
# ---------------------------------------------- #


# ---------------------------------------------- #
#             OnTriggerXXX()
#             OnCollisionXXX()
# ---------------------------------------------- #


# ---------------------------------------------- #
#             yield WaitForFixedUpdate;
# ---------------------------------------------- #



# ---------------------------------------------- #
#             OnMouseXXX
# ---------------------------------------------- #


# ---------------------------------------------- #
#             Update()
# ---------------------------------------------- #


# ---------------------------------------------- #
#           yield null;
#           yield WaitForSeconds;
#           yield WWW;
#           yield StartCoroutine;
# ---------------------------------------------- #



# ---------------------------------------------- #
#           LateUpdate()
# ---------------------------------------------- #


# ---------------------------------------------- #
#           OnPreCall()
#           OnWillRenderObject()
#           OnBecameVisible()
#           OnBecameInvisible()
#           OnPreRender()
#           OnRenderObject()
#           OnPostRender()
#           OnRenderImage()
# ---------------------------------------------- #
另一个文件中有描述

# ---------------------------------------------- #
#           OnDrawGizmos()
# ---------------------------------------------- #
另一个文件中有描述

# ---------------------------------------------- #
#           OnGUI()
# ---------------------------------------------- #
另一个文件中有描述

# ---------------------------------------------- #
#           yield WaitForEndOfFrame;
# ---------------------------------------------- #


# ---------------------------------------------- #
#           OnApplicationPause()
# ---------------------------------------------- #

# ---------------------------------------------- #
#           OnApplicationQuit()
# ---------------------------------------------- #


# ---------------------------------------------- #
#           OnDisable()
# ---------------------------------------------- #
被正式销毁时, 也包含每次 editor 热更新时的 重置

当 behaviour 类实例 被设置为 disabled 时, 此函数被调用.
当 obj 被销毁时, 此函数也被调用.

and can be used for any cleanup code. 
When scripts are reloaded after compilation has finished, OnDisable will be called, 
followed by an OnEnable after the script has been loaded.


# -- OnValidate()
    此函数的位置 不明...

    只在 editor 模式中有意义的函数, 当一个 脚本被 loaded, 或当一个变量在 inspector 中被修改时,
	此函数被调用.

	所以, 这个函数的内容, 可围绕那个刚在 inspector 中被修改的 变量展开, 比如, 修正它的范围.

	注意:
		不应在此函数中做别的事情,比如:
		新建obj, 调用其它 非线程安全的 unity api. 
		---
		因为 此函数可能不会在 main thread 中被调用, 而是在类似于 loading thread 中.

		不该在此处 执行 camera rendering 操作. 而是应该 add a listener to EditorApplication.update; 
		and perform the rendering during the next Editor Update call.


# ----------------------------------------------#
#            OnDestroy()
# ----------------------------------------------#
在一帧的末尾被调用;


一个 激活态的 go, 它的脚本里实现了 OnDestroy();

在运行时的以下场合, OnDestroy() 会被调用:
# -1-
    当这个 脚本组件被销毁时
# -2-
    当这个 激活态的 go 被销毁时
# -3-
    当这个 scene 被结束时
    (此时往往意味着, 一个新的 scene 将要被加载)
# -4-
    editor 阶段, 当从 play mode 退出时
    builded 阶段, 当关闭 app 时

观察以上行为可发现, OnDestroy() 被触发的根本原因是因为 它的 MonoBehaviour 实例被销毁了.

注意:
    如果 go 在运行之前就已经是 激活态的, 那么在运行时, 不管是否把 go 和 脚本 disactive, 只要 monobehaviour 组件被销毁, OnDestroy() 都会被触发
    ---
    反之, 若在运行时之前, go 就是 disable 态的, 那么在运行时, 不管算出 go 还是 脚本组件, 都不会触发这个 OnDestroy()


































