# ================================================================//
#                       c++ template
# ================================================================//



# ----------------------------------------------#
#        函数参数 与 move/copy构造函数
# ----------------------------------------------#
C++17 开始，没有 move 和 copy 构造函数的 类数据，
也可以通过 rvalues 扮演临时数据，充当 函数参数


# ----------------------------------------------#
#   void / void* 可以是有效的 模版类型 <T>
# ----------------------------------------------#


# ----------------------------------------------#
#  模版类型推导，并不会自动用在 返回类型 上    
# ----------------------------------------------#
如果 某个类型<RT>, 没有出现在 参数中，仅仅出现在 返回值类型上
它将不能享受 自动类型推导。
-- 必须要在 此函数被调用时，通过 func<int>() 这样显示声明


# ----------------------------------------------#
#   不要用模版参数 T 的引用类型来 传参和返回值
#      直接用 T 类型 值传递 
# ----------------------------------------------#
template< typename T >
T &foo( T &t_ ){}
---
在这个例子中，返回值是函数临时生成的，（而不是那个预想中的 参数本体）
可能会导致 返回值悬空，进而出现未定义行为。
====

# ----------------------------------------------#
# 不能在 函数/块作用域内 定义 class-template
# 只能在 全局/namespace 内声明和定义         
# ----------------------------------------------#

# ----------------------------------------------#
#  class模版，在被某个类型T实例化时，
#  它的 成员函数，只有真的被调用的那些，才会被实例化
#  这意味着，一个 clss模版实例化class，其实可以只被实例化一部分
# ----------------------------------------------#

# ----------------------------------------------#
#       class模版 偏特化
# ----------------------------------------------#
存在多种 偏特化 形式：
-1- 存在2个以上的类型，只实例化其中一个类型
	这个最好理解
	template< typename T2 >
	class B<int,T2>{};

-2- 只接受类型 T 的 指针/引用 类型
	template< typename T >
	class B<T*>{};
	---
	template< typename T >
	class B<T&>{};

-3- 只接受 类型T 的 vector模版参数
	template< typename T >
	class B<std::vector<T>>{};

-4- 原版有两个类型T1，T2，这个偏特化版合并为一个 T
	template< typename T >
	class B<T,T>{};

======
全特化后的class，已经不是模版了，而是一个 实例class，不会和 模版 产生二义性
偏特化后的class，还是一个模版。只是原初模版的子集

======
若想让用户，使用这些 全特化/偏特化版本，必须把特化版本 和 模版定义，放在同一个 .h文件中



# ----------------------------------------------#
# 当参数以 T& 类型传入时，这个参数类型不会被 decay（衰减）
# 当参数以 T 类型（值）传入时，这个参数类型会被 decay（衰减）
#     比如，从 T数组，decay to T* 
# ----------------------------------------------#


# ----------------------------------------------#
#       c++ 17 deduction guide             
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#

# ----------------------------------------------#
#               
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#

# ----------------------------------------------#
#               
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#























