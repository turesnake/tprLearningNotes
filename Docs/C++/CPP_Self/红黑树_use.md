
# ======================================================//
#                   红黑树 学习
# ======================================================//

# +++++++++++++++++++++++++++++++++++++++#
#               主原则
# +++++++++++++++++++++++++++++++++++++++#
-1- 每个节点，非黑即红
-2- root节点 和所有 leave（nil）节点为红
	此处 leave（nil）节点，并不是真的 叶节点
	而是叶节点的两个 空儿子
-3- 红父的儿子都为黑
-4- 从树中任意节点开始，遍历到任意 leave（nil）
	其路径上的 黑节点数目 都相同

--------
深度计算：
从root节点，到末端 leave（nil）节点，路径上 黑节点个数（不包含root自己）
（但是包含 leave（nil））


# ----------------------------------------------#
#       所有的 叶节点 是否都为黑色
# ----------------------------------------------#
不。所有 nil 节点为黑色。也就是 “实体叶节点” 的两个空儿子。

“实体叶节点” 的颜色 可红可黑



# ----------------------------------------------#
#       为什么要将空节点（nil）也设为黑
# ----------------------------------------------#
每次 insert 新节点后，都需要查看其 uncle 节点，然后做一系列调整。
如果此时，uncle 节点为空，就无法进行下去了。
此时人为地把这些 不存在的空节点，也设计为 “显黑色”



# ----------------------------------------------#
#         有关 插入后调整的 一些 视觉特征
# ----------------------------------------------#

=0= 一个红黑树，从视觉上，确实是平衡的
	体现出一种近似的对称性。
	比如，红色的父节点，多半有对称的 黑色子节点


=1= 只有 z节点父节点也为红色时，才会触发 插入后调整
	如果父节点为黑，则直接插入就完事了

=2= 当父节点为 红时，














