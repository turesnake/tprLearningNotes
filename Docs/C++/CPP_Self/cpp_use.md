
# ================================================================//
#                          c++ 使用技巧
# ================================================================//



# ++++++++++++++++++++++++++++++++++++++++++++++#
#                 综合
# ++++++++++++++++++++++++++++++++++++++++++++++#
--1-- 在绝大多数情景下，可以 “信赖” std::vector; 注意，是“信赖”。
	它是一种理想的 “智能数组”。

--2-- class 的主要功能 变成了 “实现RAII”。
	我们不再信任类继承，能用动态绑定的地方，就不要使用类继承（最好彻底不用）
	但是， RAII 是个好东西。

--3-- 承接上条，类继承都不用了，自然可以消灭掉：虚函数。

--4-- 因为不具备反射，C++在某些方面很不好用。
	这种时刻，可以把 二进制数据块 掏出来试试。
	二进制数据块拥有天然的动态性，尤其是在类型转换上。
	只要你不嫌麻烦。

--5-- 当发现 list 和 queue 都不好用时，
	不妨试试 set／unordered_set。
	支持 随机访问
	支持 全范围增删元素
	最后还提供了 迭代器遍历
	为什么以前没想到用它。


# ----------------------------------------------#
#       作用域 和  函数栈空间
# ----------------------------------------------#
在函数体内定义一个作用域。
在这个作用域内，定义一个变量。
就算离开了这个 作用域，这个变量暂时也不会被释放。
此时，它的引用还是能用的（但是已经算是 未定义行为了 ）
--
只有等离开这个函数栈，函数分配的所有栈空间才会被一次性清理。





# ----------------------------------------------#
#          一些常用对象的内存大小
# ----------------------------------------------#
-- 常规容器，占用：24-bytes
	- vector
	- set
	- map

-- hash容器，占用：40-bytes
	- unordered_set
	- unordered_map

-- std::function 函数指针，占用：48-bytes
	- std::function<void(int)>

-- 如果一个 class，没有一个 成员变量，此class实例占用 1-bytes

-- std::any a;
	32-bytes

-- 智能指针：
	- std::shared_ptr: 16-bytes
	- std::unique_ptr: 8-bytes


# ----------------------------------------------#
#             除零, inf, NaN
#          [ -- IMPORTANT -- ]
# ----------------------------------------------#
---
若类型是 int 等整形
当除数为：0
	除零操作会导致一个 warning：
	division by zero is undefined [-Wdivision-by-zero]
	而不是一个 编译错误，
	而且在 运行时也不会引发错误，但是这个除法的结果，是未定义的。

---
若类型是 float/double 等浮点数
当除数为：0.0
	整个除零操作，都是可接受的，不会引发 编译/运行时问题。
	最终运算的结果是 infinity

---
若类型是 float/double 等浮点数
当 除数 和 被除数 都为：0.0
	整个过程，不会引发 编译/运行时问题。
	最终运算的结果是 NaN （not a numble）

====
#include <cmath>
bool std::isinf( double x );
bool std::isnan( double x );

bool isfinite( double x );
	可同时检查 inf 和 nan


==== NaN [注意] ===
一个 nan值/变量，不等于任何一个值（包括它自己）:

(nan0 < nan1) --> false
(nan0 > nan1) --> false
(nan0 <= nan1) --> false
(nan0 >= nan1) --> false
(nan0 == nan1) --> false
(nan0 != nan1) --> true  (唯一的例外)
---
此处，nan0, nan1 只要有一个为 NaN，即可满足。

这将意味着：
	nan0 <= nan1 --> false 
	!(nan0 > nan1) --> true (!!!!!!!)
	---
	这显然是未预期的结果。
	所以，如果觉得比较数 可能是 nan，就不要随便嵌套 !号来反转结果

-----
std::min(a,b)
std::max(a,b)
	若 参数中存在 inf，这个 inf数（有正负）的表现就和普通数一样
	若 只存在一个 nan，这个 nan 已经会落选，
		最后会返回另一个 普通数，或者 inf
	若 {a,b} 都为 nan，返回值才会是 nan


# ----------------------------------------------#
#                 constexpr 
# ----------------------------------------------#
== constexpr 可用于 构造函数：
class A{
public:
	constexpr A()=default;
	constexpr A(int a_):
		a(a_)
		{}
	//===//
	int a;
};
这样就能实现：
	constexpr A ca {123};



# ----------------------------------------------#
#        std::size_t -- size_type
# ----------------------------------------------#
size_type 使用起来很麻烦。
可以暂且用 std::size_t 来代替
	(尤其是标准库容器)

size_t -- std::size_t
	两者可以被看作相等的
	所以，简便起见，直接用 size_t 就行



# ----------------------------------------------#
#                  RAII
# ----------------------------------------------#
	resource acquisition is initialization
	“资源获取就是初始化”

	借用 class 的自动析构 来实现的 资源管理。
	--------
	对于那些 需要反复 “创建-销毁” 的资源（宏观）
	的最好的 管理方式。

	--------
	应该强化 这个工具 的使用。



# ----------------------------------------------#
#      迭代器 相加相减: advance ／ distance
# ----------------------------------------------#

#include <iterator>

void std::advance (InputIterator& it, Distance n);
std::distance( fstIt, lstIt );

#  不要直接使用 lstIt - fstIt,
#  在 mac 的 vscode 中，这会报错。  

#  注意：
#  参数 fstIt 应该输入 更靠近 v.begin() 的那个迭代器
#  参数 lstIt 应该输入 更靠近 v.end()   的那个迭代器

# std::advance 并不检测 参数it 在被位移后是否越界
	

# ----------------------------------------------#
#             跨容器的 迭代器
# ----------------------------------------------#
std::vector<int> v {}:
std::set<int> st ( v.begin(), v.end() );

# 如上例子所示，可以用 vector 的迭代器，来初始化 set 容器
# 实践中，最好先测试下 



# ----------------------------------------------#
#            nullptr  代替  NULL
# ----------------------------------------------#
ptr = nullptr;
#  避免使用 NULL



# ----------------------------------------------#
#          合理使用 友元 / friend
# ----------------------------------------------#
友元可以让一些 联系紧密的 class 之间方便数据访问
同时强化对外部访问的 数据封装。

两个class，可以相互将对方设置为自己的 友元。
===

友元不具备继承关系。
类A 将 类B 设置为自己的 友元，
不意味着，类B的子孙，也可以访问类A
不意味着，类B的友元，也可以访问类A
不意味着，类A，可以访问类B
===

一些类似 operator+ 的二元运算符，必须被实现为 友元
（如果这个运算符重栽函数，想要访问 私有数据的话）



# ----------------------------------------------#
#                 this
# ----------------------------------------------#
class A;

#  A中的 this，类型为 
	A *const this;
		//- 一个 const指针(this)，指向 变量: A实例。
		//- 此处的 const 是修饰 指针的。
		//- 也就是说，指针（this）不可被修改
		//  但指针指向的实例: A实例，则是可改写的。

#  如果在使用 this 时发生问题，请将其转换为 合适的 类型。



# ----------------------------------------------#
#         emplace   代替   push
# ----------------------------------------------#

vector<string> v;
v.emplace( "aaa" );
v.emplace( "bbb" );
v.emplace( "ccc" );

#  尽可能使用 emplace 来 代替 push 
#  emplace 将直接在容器中 构造 obj
#  push 则是 将 一个外部的 obj，复制进 容器中

v.push_back( "aaa" );

#  隐式地 先创建了一个 string obj，然后再将其存入 容器 v 中


# ----------------------------------------------#
#              std::move(val)
# ----------------------------------------------#

#include <utility> 

coll.insert( std::move(x) );

#  将 元素x移动到 容器coll中。
#  常规的 insert 操作会 将参数 x 复制一份 到 容器中。

#  如果想要让一个 类型接受 这种 移动操作
#  可重载其 成员函数:

class X{
public:
	//---- 构造函数 ----//
	X( const X& lval ); //- copy
	X( X&& rval );      //- move
	
	//---- copy ----//
	X& operator= ( const X& lval ); //- copy
	X& operator= ( X&& rval );      //- move

	//---- insert ----//
	void insert( const T& x ); //- copy
	void insert( T&& x );      //- move
};


#  不用复制，提高性能的利器。有望全面推广使用
#  C++STL:p-20

#  ==== 2018_1225_更新 ====

--  v.push_back(val) 
	会调用 v.push_back(const T&)版本
	此时会 复制一份 val 到 容器v中

	v.push_back( std::move(val) ) 
	会调用 v.push_back(T&&)版本
	此时会 将 val 移动到 容器v中
	这会比 上面的 copy 快些（毕竟不需要重新建一个实例 ）
	但是，val 必须支持 move 操作：
		X(X&& rval_ );
	否则会报错.

	或者说，std::move(val) 对 val的类型有要求。
	如果 val 是我们定义的 一种复杂 class。
	那么它的 
		X(X&& rval_);
	就需要好好编写。

-- 从上述信息来看。std::move 用于 非 std对象时，有一定的门槛。
	在 未精进 次部分知识之前，
	请全面停用 std::move 功能。


# ----------------------------------------------#
#     RVO [-Return Value Optimization-]
#        std::move 作为 返回值
# ----------------------------------------------#

T foo(){
	T t {};
	return t;
}
此函数将引发 编译器的 RVO 机制，返回值的那一步复制操作 会被优化掉

T foo(){
	T t1 {};
	T t2 {};
	if( bool ){
		return t1;
	}else{
		return t2;
	}
}
由于最终 返回值到底选哪一个，在编译阶段是未知的，所以不会引发 RVO 机制。
==========

总体而言，RVO机制 要优于 std::move, 请尽可能使用 RVO。
==========

std::move 会将一个 T 变量，变成 T&& 类型，不再与 函数返回值类型 T 相同
此时就算显示要求使用 std::move ：
	return std::move(t1);
也是不会成功的。
只有当把 返回值类型也改为 T&& 时，
return std::move(t1); 中要求的 move 操作才是被执行（还要求 T 定义了 move运算符）



# ----------------------------------------------#
#          std::unordered_set
#          std::set
# ----------------------------------------------#
std::unordered_set<IntVec2> set {};
	会导致编译错误：
	call to implicitly-deleted default constructor of 'std::__1::hash<IntVec2>

但是换成 std::set, 就没问题...


# ----------------------------------------------#
#        在构造函数前使用 explicit
# ----------------------------------------------#

class A{
public:
	explicit A(string _str){};
};
	
#-- explicit 的主要功能是，阻止 参数_str 的隐式转换
    比如，原本可以通过：
		A a{999};
	来创建一个 A实例，此时的 参数999，将被隐式转换为 "999"
	但是加上 explicit 关键词后：
	构造函数 就只能使用 规定的 类型来 创建实例了。

#-- 这种规则只适用于 “单参数构造函数”
	如果你的构造函数 用有多参，就不用添加 explicit.

#-- A a = "999"; 这种 “拷贝形式的初始化” 也是不支持的。
	只能使用 A a{"999"};


#-- 总结，explicit 只需用在合适的位置。


# ----------------------------------------------#
#          std::initializer_list<>
# ----------------------------------------------#

void print( std::initializer_list<int> vals ){
	for( const auto& i : vals ){
		cout << i << endl;
	}
}

print( {1, 45, 66, 778} );

#  如上所属，可以直接向函数 传递 一个 “系列值”

#  initializer_list<> 也拥有 迭代器

#  脑洞大开的一个 东西
#  可在此函数之外，制作包裹函数。
#  C++STL:p-15


# ----------------------------------------------#
#          在 for each 中使用 & 引用
# ----------------------------------------------#

vector<int> v{ 1, 33, 404 };

for( const auto& i : v ){
	cout << i << endl;
}

#  如果仅仅想要 读取 容器的元素，推荐用 const auto&
#  如果想要 改写容器的元素，推荐用 auto&
#  若写成:

for( auto i : v ){
	i = 0;
}

#  此时修改的 不是 容器中的元素，而是 被复制到 for循环中的 临时元素
#  （容器 v 中的元素 并未被修改）



# ----------------------------------------------#
#       std::function + std::bind
# ----------------------------------------------#
#  无双利器 
#  C++14 后，考虑用 lambda 来替代 bind

#include <functional>
using namespace std::placeholders;

using FUNC = std::function<void(int, int)>;

FUNC newfunc {nullptr};

newfunc = std::bind( somefunc, _1, _2 );

if( newfunc != nullptr ){
	newfunc( 11, 22 );
}

#  std::function实例是个 函数对象，可在任何时候设置其为 nullptr
	表示 空。 
	通过 (newfunc != nullptr) 来判断 此函数对象 是否为空。

----------
一个 functor 指针，占用 48-bytes


# ----------------------------------------------#
#     lambda 直接作为 std::function 类型返回值
#     并且返回值时 std::optional 类型时
#     应该 显式 声明 lambda 返回值类型
# ----------------------------------------------#

using F_a = std::function<std::optional<int>(int)>;

F_a boo(){
	return []( int i_ )->std::optional<int>{
		if( i_%2==0 ){
			return { i_*2 };
		}else{
			return std::nullopt;
		}
	}
}

---------
在上面这个例子中，可以直接用一个 lambda 表达式，
作为 std::function 类型的 返回值。

但是，最好为 lambda 添加显式的 返回值类型声明 “->...” 这部分。
尤其是在 使用 std::optinal 作为 仿函数 的返回值类型时。

如果不显示声明 lambda 返回值类型
就要在lambda 体内，返回语句中，明确写出：
	return std::optional<int> { i };
	return std::optional<int> { std::nullopt };


# ----------------------------------------------#
#            lambda 捕获引用
# ----------------------------------------------#
当lambda 捕获的引用变量 脱离原本作用域（比如一个函数）
此引用变量会失效。此时会导致 lambda 出错。

所以，不要去捕获一个 局部变量的 引用类型 
===
隐式捕获：值捕获，引用捕获。
	[=](){}
	[&](){}

===
如果在 [] 中标明了 值捕获: [=]
但是传入的 变量却是个引用变量。
其实还是会被以值传递的方式传递。

=== 以上描述的方式都不推荐 ===
在 C++14 之后，推荐使用 init capture 机制：
	[a_l=a](){}
以值传递的形式捕获变量a，同时在 lambda-class 体内，
创建一个 成员变量 a_l, 其值等于 外部的 a
这是最安全最推荐的做法。


# ----------------------------------------------#
#    lambda 在捕获列表中 创建变量 “塞私货”
# ----------------------------------------------#
	[ uptr=std::make_unique<A>() ](){}
本质就是在 lambda-class 中新建一个 成员变量 uptr.
这句话会在 lambda-obj 被创建的那一刻被调用。
然后一直存储在 lambda-obj 体内，直到 lambda-obj 被销毁。
---
如果把这句话写进函数体内，{}里，含义就变成了，
在这个函数被调用时，才创建这个 uptr变量。
---


# ----------------------------------------------#
#            lambda 修改捕获变量
# ----------------------------------------------#
int a = 123;
auto f = [a]()mutable { a++; };

必须为值捕获。
添加 mutable 之后，可以在 lambda 函数体内，修改 捕获的值变量

====
如果变量 是以 引用捕获 实现的，那么不需要这么麻烦
直接可以修改 捕获变量


# ----------------------------------------------#
#       static_cast 和  floor()
# ----------------------------------------------#
当要把一个 float值，转换为 int 类型时，
正确的格式是：
	static_cast<int>( floor(Val) );

如果缺少了中间的 floor()，当参数为 负数时，将出现错误


# ----------------------------------------------#
#       std::begin(v) / std::end(v)
# ----------------------------------------------#

int v[4] {1, 22, 606, 99};

for( auto i = std::begin(v); i != std::end(v); i++ ){
        cout << *i << endl;
}

#  在这个例子中，容器 v 是个普通数组，没有迭代器
#  但是仍可通过 std::begin(v) 来获得一个 迭代器。



# ----------------------------------------------#
#             container.at( idx )
# ----------------------------------------------#

vector<int> v{ 1,2,3 };

for( int i=0; i<3; i++ ){
	cout << v.at(i) << endl;
}

#  当 v[idx] 越界时，不会有任何警告
#  推荐使用 v.at(idx); 越界时会自动报错终止 



# ----------------------------------------------#
#              类内定义的 类型别名
# ----------------------------------------------#

class A{
	
public:
	typedef int SubType;
	
	//...
}; 

#  此例中，SubType 是一个在类内部 被定义的 类型别名。
#  它可以像 成员变量 和 成员函数一样，在类外部被访问

A::SubType val = 8;

但是需注意，这个 类型别名，必须定义在 public 模块内


# ----------------------------------------------#
#                  tuple
# ----------------------------------------------#

#include<tuple>

tuple<int, float, string> t1( 12, 0.56, "aaa" );

#  tuple，异质元素列。 可被视为一个 强化版的 pair。
#  tuple 不是常规的 容器，无法使用迭代器。
#  tuple 的元素类型可以是 引用：

string s;
tuple<string&> t(s);
get<0>(t) = "hello";

#  这个操作将直接改写 s 的内容
#  实现2:

#include<functional>
auto t = make_tuple( std::ref(s) );

#  C++STL:p-68



# ----------------------------------------------#
#              Type Trait
# ----------------------------------------------#



# ----------------------------------------------#
#             ::glob_val
# ----------------------------------------------#
#  当 :: 符号前没有标明命名空间时，
#  表示 这是在指向一个 全局变量


# ----------------------------------------------#
#             nocopyable
# ----------------------------------------------#
#  当一个类不需要 拷贝构造函数时，可通过：

class FOO : tpr::nocopyable {};

#  来实现。
#  tpr::nocopyable 需要自行实现。

#   注意，这类实例 将不可用于 push_back 等场合。
    请确保，自己的 类实例 不会被 到处 复制。再使用 nocopyable
	比如一些全局变量，就是适用的。



# ----------------------------------------------#
#           set / unordered_set
# ----------------------------------------------#
-- 支持 随机访问
-- 支持 全范围 元素增删
-- 支持 迭代器遍历

在很多适合，比 list，queue 好用。

不适合在 set的遍历函数中 直接 删除元素。
可以先把要删除的元素 记录在一个 vector 中，之后再逐个删除。



# ----------------------------------------------#
#     const A &a;  a.func();  引发的错误
# ----------------------------------------------#

class A{
public:
	void func_A();
	void func_B() const;
};

const A &a = XXX;
a.func_A();       //-- 此行将引发错误 
a.func_B();       //-- 此行却能运行

#  原因在于：
	类方法 拥有一个 隐藏的参数：this，是一个指针。
	但是在 void func_B() const; 这种类方法中，
	this 就是一个 const 指针。

	在 a.func_A(); 调用中，本质就是将一个 const A* 参数
	传递进一个 A* 形参。
	参数类型不匹配，进而出现问题。

#  这也进一步表明，能让一个 类方法变成 const 的，就尽可能让它变成 const。
   这能拓宽 这个方法的 适用范围。


# ----------------------------------------------#
此外，经测试，函数对象 可当作:
	vector,
	set,
	map,
	的 key，val 元素。

以及：
函数对象 可以放进 unordered_map 的 val 中。
===
如果想要让 class 支持 unordered_set, unordered_map
应该为其 重栽 std::hash 函数



# ----------------------------------------------#
#             inline  细则    (c++17)
# ----------------------------------------------#
主要有两大类：
- inline函数;
- inline方法;
-----------------------
==1== inline函数:
	- 可以定义在 h文件中（通常也推荐这么做）
	- 可以拥有多份定义（但必须是完全相同的）

==2== inline方法:
	- 直接定义在类内容的方法，自动是 inline的
		（加不加 inline 关键词都可以）

	- 如果要让一个 定义在类外的 方法也内联，
		可以在 类内类外 都标明 inline 关键词
		（书上推荐仅在 类外方法定义处 写 inline）

	但是！！！
	此处的 类外定义，必须还是 在同一个 h文件中。
	（也就是，在 h文件中 声明类方法，并在下方类外，定义方法）
	----
	这踏马有什么用？？？
	----
	这意味着，如果我们必须把一个 方法定义在 cpp文件中，
	它就不能是 inline 的了
--------------------------
为什么要把一个 类方法的 定义放到 cpp文件中？
多数时候是因为 “include冲突”。



# ----------------------------------------------#
#                 除法 "/" 
# ----------------------------------------------#
在 执行 "/"操作时，真正含义是：
	“向0取数”
这在处理负数是会出问题。
推荐的做法：

-1- 不管目标数是 整数还是浮点数，
	一律改用 浮点数的"/"运算
-2- 然后执行一次 math.floor() 运算，
	获得我们想要的 “向低位取数”
-3- 最后转换为需要的类型 ( int/float )



# ----------------------------------------------#
#      当在 struct 中放入 vector实例
#      该如何 实现 struct 字节对齐
# ----------------------------------------------#
- 一个 vector实例 占有 24-bytes
- 同时将 此struct 的 对齐标准提升到 8-bytes


# ----------------------------------------------#
#             std::lock_guard
# ----------------------------------------------#
-- 	std::mutex m;
   	{
   		std::lock_guard<std::mutex> lg(m);
   		...
   	}
   	---------
	在一个小型作用域内，创建一个 lock_guard 实例
	此实例将此用 传递给他的 一个 mutex实例。
	lock_guard 实例 将一直独占这个 mutex实例，
	直到 lock_guard 实例 自己被销毁。
	（通常是离开作用域）

-- 这是一种 “只管开头不用管结尾” 的安全便捷的用法。
	是个天然的 RAII 策略。


-- 	int ret = std::try_lock( m1, m2 );
	if( ret == -1 ){
		std::lock_guard<std::mutex> lm1(m1, std::adopt_lock);
		std::lock_guard<std::mutex> lm2(m2, std::adopt_lock);
		//... do sth...
	}else{
		cout << "err" << endl;
	}
	----------
	如上例，有时需要在 lock_guard 外部 锁定某个 mutex
	尤其是 当我们需要一次性绑定 数个 mutex 时。 
	此时，lock_guard 构造函数应当加上 std::adopt_lock 参数
	表示，自己接收的是一个 已经上锁的 mutex 实例。


# ----------------------------------------------#
#   std::lock_guard 和 std::unique_lock 的区别
# ----------------------------------------------#
-- lock_guard 受到更大的限制：
	只能在其实例 构造阶段 锁住 mutex
	在其实例 析构阶段 解锁 mutex

-- unique_lock 实例可以在其 生命周期内
	锁定和解锁 mutex 若干次。

-- unique_lock 实例 在 构造阶段，甚至可以不立即 锁定 mutex

-- unique_lock 可以传递 自己的状态（在此略）

-- 在 unique_lock 中：
	如果 析构阶段，发现自己 锁定了mutex，则执行解锁。
	如果 发现未锁定，则什么也不做。


# ----------------------------------------------#
#            互斥锁陷阱 [一]
# ----------------------------------------------#
--  谨防一种格式：
	if( !atom_find_XXX() ){
		atom_insert();
	}
	-----
	这种 查询+创建 的过程应该做成一个整体
	整体原子化。
	不然就容易出现 跨线程bug


# ----------------------------------------------#
#       std::shared_mutex  读写锁 [c++17]
# ----------------------------------------------#

int               globVal;
std::shared_mutex sMutex;

int read(){
	int ret;
	{//- atom
		std::shared_lock<std::shared_mutex> sl(sMutex);
		ret = globVal;
	}
	return ret;
}

void write( int _val ){
	//- atom
	std::unique_lock<std::shared_mutex> ul(sMutex);
	globVal = _val;
}
	-------
	以上是，读写锁的用法


# ----------------------------------------------#
#        删除 引用 的原数据后，再次访问 引用
#        其结果 未定义
# ----------------------------------------------#
引用的本质还是个指针（只有临时作用域的指针）
当原数据被删除后，引用并没有差错机制。
再次访问引用，仍然会去 访问原始地址。。。。

---
引用在被创建之后，其地址就和 目标变量的地址一致。
但是，引用还是可以重指向另一个 变量的。
但引用的地址并不改变...


# ----------------------------------------------#
#        当 vector等容器 添加元素，
#        指向此容器的 迭代器，指针，引用 可能失效
# ----------------------------------------------#
但在实际使用中，并为遇到此问题

想确认其 具体内容。
该如何 传递 容器对象？？？

...


# ----------------------------------------------#
#       clear() 对 reserve() 无影响
# ----------------------------------------------#
目前确认的无影响容器有：
	vector
	unordered_set
	unordered_map
	---
所以，上述容器，只需在最初阶段 reserve 一次
之后便可一直使用


# ----------------------------------------------#
#              std::chrono
# ----------------------------------------------#
-1-:
	std::chrono::steady_clock::time_point zeroP 
		{ std::chrono::seconds{0} };
	---
	获得一个 值为0 的 time_point 变量

-2-:
	std::chrono::steady_clock::time_point currentP 
		= std::chrono::steady_clock::now();
	---
	获得当前 时间点的 time_point 变量；

-3-：
	std::chrono::duration<double> delta 
		= std::chrono::duration_cast<std::chrono::duration<double>>( p1 - p2 );
	---
	计算2个 time_point 的间距，
	单位为 duration<double>
	
-4-:
	delta.count()
	---
	获得 duration<double> 的tick数值。根据模版参数，可为 浮点数



# ----------------------------------------------#
#                 std::any
# ----------------------------------------------#
可以把 any 看作一个 smarter void*/shared_ptr<void>
所以，它自己就是智能指针/容器。
当 any变量被销毁，它会自动销毁 自己存储的数据。

当 any变量被复制，它体内的数据也会被复制（不同于 sptr）

-1- Create:
	std::any a = 0.345;
	std::any a( 1034 );
	std::any a( std::in_place_type<int>, 87 );
	std::any a = std::make_any<T>();
	---
	此时，编译器 会自动推导出 变量类型
	推荐最后的 std::make_any

-2- Change val:
	std::any a = 111;
	a.emplace<double>(88.89);

-3- ：
	std::any_cast<double>(a)
	---
	将存储在 a 中的数据，再变回原来的类型
	这里的类型检测较为严格， double -> float 会编译出错
	float -> double 则能成功（隐式类型提升）
	---
	如果出错，会爆出 std::bad_any_cast

-4-：
	a.has_value() -> bool
	---
	表示 是否有值

-5-：
	a.reset();
	---
	清空容器

-6-:
	void swap(any & other);
	---
	与另一个 any变量 交换数据


-7-:
	std::any 包含的那个 class，不支持 move-only type
	因为 std::any 变量 本身是支持 复制的:
		std::any oldV;
		std::any newV = oldV; 
	具体地说，被包裹的class里，不允许出现 uptr 指针（递归）
	---
	解决办法有二：
	-1- 讲所有 uptr ，替换为 sptr
	-2- 被包裹的 class Boo，自己实现一个 移动构造函数：

		Boo( const Boo &b_ ){
			tprAssert(0);
		}

	一方面，提供了 移动构造函数，编译时，any 不再报错
	一方面，运行时确实不允许 std::any 自动复制 目标数据
	一旦复制，直接报错
	---
	进一步，可以为其制作一个 祖class，所有具象class，都继承它
	



# ----------------------------------------------#
#      反向迭代器 -> 普通迭代器    
# ----------------------------------------------#
rIt.base(); 就能获得 普通迭代器

尤其是，std::map.erase() 参数需要普通迭代器
此时可以通过 rIt.base() 来获得




# ----------------------------------------------#
#     <cmath>  modf()  获取一个数的 小数部分
# ----------------------------------------------#
double modf(double x, double *integer);
----
double integer {};
double fract = modf( 123.56789, &integer );
----
	现在，
	integer = 123;
	fract = 0.56789;





# ----------------------------------------------#
#               std::variant
# ----------------------------------------------#
安全版的 union
常用方式：
using tt = std::variant<int, double, std::string>;

tt a { "abc" };

if( auto valPtr = std::get_if<std::string>( &a ) ){
    cout << "get str; val =  " << *valPtr << endl;
}
-- 使用 std::get_if 来检测类型, 不会报错的版本

-- 类型支持 enum class，哪怕指向相同的 底层数据类型

===
测试表明，支持 sptr/uptr 作为类型
	std::variant< std::unique_ptr<A>, std::unique_ptr<B> >;
	更为常用

=== 
首元素最好设置为 std::monostate
这样，当 变量并未被分配时，v.index() 将返回0 
（指向首类型，一种检测 是否为空的方式）

===
v = {};
以此来 将 变量 v，设置为空


# ----------------------------------------------#
#         std::optional 的访问性能
# ----------------------------------------------#
现有测试表明，optional 的额外开销几乎可以忽略不计
可以大胆地使用与 各个方面 

测试：
小型 数据 的 optional 测试对照。
- double 				regVal;
- std::optional<double> optVal;
	而且，opt态，增加了全套的 tprAssert 检测

测试结果：
-- init debug:
reg: 0.103286
opt: 0.32647

-- init release
reg: 0.0257265
opt: 0.0274931

-- get debug
reg: 0.398334
opt: 0.459998

-- get release
reg: 0.0486438
opt: 0.0480524

==========
增加额外的 opt,它的性能开销是可以承担的


# ----------------------------------------------#
#          右值引用 / 完美转发 
# ----------------------------------------------#





# ----------------------------------------------#
#       injected class name (注入类名)
# ----------------------------------------------#
===== 1 =====
void X() {}
class X {
public:
    static X create(){ return X(); }
}
	---
	在这个案例中，create() 函数中的 X()
	到底会调用外部函数，还是自身这个类名。
	由于 注入类名 机制的存在，它会调用类名本身。


===== 2 =====
在一个类模版体内，不再需要 F<T> 这么一个全称来指向本 类模版。
而是可以直接用 F 就行。
因为 注入类名 机制，会自动找打 类模版
===

在更早之前，一个class的名字，是不能合法地出现在自己的体内的。


# ----------------------------------------------#
#               alignas 对齐计算 说明符
# ----------------------------------------------#
在编译器计算，目标的 内存对齐字节数：

alignas( 表达式 )		
alignas( 类型标识 )		
alignas( 包 ... )		

具体用法自查...



# ----------------------------------------------#
#               std::launder      
# ----------------------------------------------#
如果我们采用 C式风格，在一个已经分配了对象的内存上，释放对象
原地再初始化新内存，可能引发问题。此时，编译器也许没意识到这件事的发生，
它仍然以为，原始对象是存在的。

为了避免这个问题，我们要在 对内存指针，做类型转换时，用 std::launder 
来显式处理。

注意，将一个内存指针，比如 void*, 转换成 原始对象的类型指针。是不需要
std::launder 操作的。因为在这个过程中，内存并没有被复用。

具体用法自查... 


# ----------------------------------------------#
#               
# ----------------------------------------------#


# ----------------------------------------------#
#               
# ----------------------------------------------#












