# ================================================================ #
#              constructor  类实例的 初始化
# ================================================================ #



### -- 实例构造函数 先后执行顺序: -- ###

# +++++++++++++++++++++++++++++++++++++++ #
# -1- 初始化本 class 自身的组件,类成员
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
比如:
	class A{
		Dog d = new Dog();
	}

此处的 d 是一个 类成员, 它的这句初始化语句会被最先执行;


# +++++++++++++++++++++++++++++++++++++++ #
# -2- 隐式调用 基类 无参 constructor
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

常规的构造函数: Dog(){}; 等同于 

    Dog() : base()
    {
        ...
    }

# ------------ #
当然也可显式指定需要调用的 基类构造函数:

    Dog( int age ) : base( age ) {
        ...
    }

# ------------ #
甚至可以调用 另一个本类构造函数:

    Dog( int age, string name ) : this( age ) {
        ...
    }

此处, 冒号后方的构造函数, 要先于前面的构造函数 被执行;
此法常常用来减少重复代码,

也有人提出可以将公共代码放在一个外部 方法中, 然后所有 构造函数都调用之,
这是 不推荐的行为 !
    -1-
        构造函数体内的代码, 能得到编译器的 特殊优化;
    -2- 
        有些行为只有 构造函数 能完成,
        比如, readonly 字段 只能在 构造函数体内被初始化;
        (这一限制只针对 readonly 字段, 而不针对 readonly 属性 ) 



# +++++++++++++++++++++++++++++++++++++++ #
# -3- 执行本 class constructor 函数体内容;
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
	
	public Derived(){
		...
	}

这里的内容;

# 禁止在此函数体内调用 虚函数;
    如果是这样:
    可能会在 基类构造函数中调用 虚函数, 这个虚函数需要访问 派生类函数的实现体,
    而此时, 仍然执行 基类初始化, 派生类尚未初始化完毕,

# 隐式默认构造函数
    如果用户没有定义任何 构造函数, 编译器将自定义一个:

        public Dog(){}

    可以看到它是无参的, 而且函数体为空; (意味着不引入额外代码)
    
    但只要用户定义任意一个构造函数, 这个 隐式默认构造函数 就都不会被生成;



# +++++++++++++++++++++++++++++++++++++++ #
# -4- 执行 对象初始化语句 Object Initializers
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
也就是:
	Derived d = new Derived(){ ... };

此处的 {...} 中的内容;




# --------------------------------------- #
#       struct 的初始化
# --------------------------------------- #

/*
        struct A{
            A( int val_ ){ ... }
        }

        此时是可以调用 "无参构造函数" 的:

            A a = new A();

        哪怕你没有在 代码中显式定义 无参版本的构造函数;
*/

上面这段内容, 有待实验和翻书...











